{
  "data": {
    "averageCompleteTime": 545.0,
    "subjectList": [
      {
        "id": "11367",
        "version": 3,
        "type": 1,
        "title": "有 n 个按名称排序的商品,使用对分查找法搜索任何一商品,最多查找次数为 5 次,则 n 的值可能为?( )",
        "optionA": "5",
        "optionB": "15",
        "optionC": "30",
        "optionD": "35",
        "answer": "C",
        "analyzeContent": "对分查找最多查找次数 m 与个数之间 n 的关系是: n 对 2 的对数的取整后加 1 ,现在最多查找次数是 5 次,因此 n 的取值范围在 [2^4+1,2^5] 即 [16,31] 之间,因此选 C .",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11368",
        "version": 3,
        "type": 1,
        "title": "下列有关分治算法思想的描述不正确的是?( )",
        "optionA": "将问题分解成的子问题具有相同的模式",
        "optionB": "当问题足够小时,可以直接求解",
        "optionC": "可以将子问题的结果合并成原问题的解",
        "optionD": "将问题分解出的各个子问题相互包含,相互之间可以有公共子问题",
        "answer": "D",
        "analyzeContent": "将问题分解出的各个子问题是相互独立的,即子问题之间不包含公共子子问题",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11369",
        "version": 3,
        "type": 1,
        "title": "下列问题使用分治算法思想的是?( )",
        "optionA": "求 100 以内的素数",
        "optionB": "求 100 个整数之和",
        "optionC": "求斐波那契数列第 n 项",
        "optionD": "快速排序算法对 n 个数排序",
        "answer": "D",
        "analyzeContent": "快速排序算法使用了分治算法.因此选 D .",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11370",
        "version": 3,
        "type": 1,
        "title": "李宇同学利用 Python 语言编写了一段\"根据出生年月判断生肖属相\"的程序,调试运行时,程序没有报错且顺利运行,但未能正确输出对应属相,造成这个结果的原因可能是?( )",
        "optionA": "程序语句语法错误",
        "optionB": "时间复杂度太高",
        "optionC": "求解算法逻辑错误",
        "optionD": "Python 环境配置不对",
        "answer": "C",
        "analyzeContent": "程序能正常运行,排除了其他三个可能.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11371",
        "version": 3,
        "type": 1,
        "title": "一般来说,递归需要有边界条件,递归前进段和递归返回段.当不满足边界条件时,( );当满足边界条件时,( ).",
        "optionA": "返回,前进",
        "optionB": "中断,前进",
        "optionC": "前进,返回",
        "optionD": "中断,返回",
        "answer": "C",
        "analyzeContent": "递归运行的条件,不满足边界条件前进,满足返回.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11372",
        "version": 3,
        "type": 1,
        "title": "以下哪一项不是递归算法的特征?( )",
        "optionA": "要实现递归必须有一个函数,并且在这个函数体内要自己调用自己.",
        "optionB": "递归必须要有判断条件 , 这个判断条件可以是判断次数.",
        "optionC": "到达判断的条件后必须有返回,目的是结束递归.",
        "optionD": "未到达判断条件时,不可以返回该函数.",
        "answer": "D",
        "analyzeContent": "未到达判断条件时,可以返回该函数,也可以不返回.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11373",
        "version": 3,
        "type": 1,
        "title": "关于斐波那契数列,下列空白处的代码填写正确的是?( ) def func(num): if num==1: return 1 elif num==2: return 1 else: lst=[] b=input(' 请输入选择的数字: ') b1=int(b) for a in range(1,b1+1): print(func(a)) lst.append(func(a)) a+=1 print(lst)",
        "optionA": "return func(num+1)+func(num-2)",
        "optionB": "return func(num-1)+func(num)",
        "optionC": "return func(num-1)+func(num-2)",
        "optionD": "return func(num-1)+func(num+2)",
        "answer": "C",
        "analyzeContent": "斐波那契数列,从第三项开始 , 每一项都等于前两项之和.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11374",
        "version": 3,
        "type": 1,
        "title": "在有序列表[2,3,10,15,20,25,28,29,30,35,40]中,使用二分法查找20,需要查找多少次能找到?( )",
        "optionA": "5",
        "optionB": "4",
        "optionC": "3",
        "optionD": "2",
        "answer": "B",
        "analyzeContent": "可以模拟二分法的执行过程分析得出.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11375",
        "version": 3,
        "type": 1,
        "title": "下列程序输出正确的是?( ) def ac(n): if n < 0: return else: ac(n-1) print(n) ac(4)",
        "optionA": "0,1,2,3,4",
        "optionB": "1,2,3,4",
        "optionC": "0 1 2 3 4",
        "optionD": "1 2 3 4",
        "answer": "C",
        "analyzeContent": "依次输出 0-4 , print() 默认换行.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "算法优化",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11376",
        "version": 3,
        "type": 1,
        "title": "阅读下列程序,运行结果正确的是?( ) def power(x,y): if y==0: return 1 else: return x * power(x,y-1) print(power(4,5))",
        "optionA": "243",
        "optionB": "81",
        "optionC": "1206",
        "optionD": "1024",
        "answer": "D",
        "analyzeContent": "power(a,b) 表示 a 的 b 次幂,当 y 不等于 0 ,返回 x*power(x,y-1) .据题, x=4 , y=5, 因此 4*power(4,4) ,即 4* ( 4 的 4 次幂),结果为 1024 .",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11377",
        "version": 3,
        "type": 1,
        "title": "下载但不安装一个第三方库的命令格式是?( )",
        "optionA": "pip search 第三方库名",
        "optionB": "pip uninstall 第三方库名",
        "optionC": "pip install 第三方库名",
        "optionD": "pip download 第三方库名",
        "answer": "D",
        "analyzeContent": "pip search 为搜索三方包 pip install 为安装三方包 pip uninstall 为卸载三方包",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11378",
        "version": 3,
        "type": 1,
        "title": "不需要使用 Python 的 pip 工具安装的是?( )",
        "optionA": "Python 标准库",
        "optionB": "第三方库",
        "optionC": "用户自己开发的库",
        "optionD": "Python 扩展库",
        "answer": "A",
        "analyzeContent": "其它要安装",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11379",
        "version": 3,
        "type": 1,
        "title": "使用 lambda 定义匿名函数如下: f=lambda x:x+1 ,则 f(f(1)) 代码运行结果是?( )",
        "optionA": "1",
        "optionB": "2",
        "optionC": "3",
        "optionD": "会报错",
        "answer": "C",
        "analyzeContent": "f(1)=2 , f(2)=3",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "匿名函数",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11380",
        "version": 3,
        "type": 1,
        "title": "关于函数,以下选项中描述错误的是?( )",
        "optionA": "函数是一段具有特定功能的,可重用的语句组.",
        "optionB": "函数能完成特定的功能,对函数的调用不需要了解函数内部实现原理,只要了解函数的输入输出方式即可.",
        "optionC": "使用函数的主要目的是减低编程难度和代码重用.",
        "optionD": "Python 使用\" del \"保留字定义一个函数.",
        "answer": "D",
        "analyzeContent": "Python 使用\" def \"保留字定义一个函数.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11381",
        "version": 3,
        "type": 1,
        "title": "某自定义函数有两个参数,并且这两个参数都指定了默认值.我们在调用这个函数时,最少需要提供几个实参?( )",
        "optionA": "0",
        "optionB": "1",
        "optionC": "2",
        "optionD": "3",
        "answer": "A",
        "analyzeContent": "只要有默认值就可以省略.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11382",
        "version": 3,
        "type": 1,
        "title": "以下关于 Python 中使用函数的描述,错误的是?( )",
        "optionA": "程序里一定要有 main 函数.",
        "optionB": "使用函数前要先定义函数.",
        "optionC": "函数在被调用时才执行.",
        "optionD": "函数执行结束后,程序执行流程会自动返回到函数被调用的语句之后.",
        "answer": "A",
        "analyzeContent": "Python 程序不必一定要有 main 函数.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11383",
        "version": 3,
        "type": 1,
        "title": "在 Python 中,函数通过可变参数 *args 传入的参数,在函数内以哪种数据类型存储?( )",
        "optionA": "元组",
        "optionB": "列表",
        "optionC": "集合",
        "optionD": "字典",
        "answer": "A",
        "analyzeContent": "可变参数在函数内以元组方式存储.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11384",
        "version": 3,
        "type": 1,
        "title": "下列关于函数调用的说法正确的是?( )",
        "optionA": "调用函数时一定要赋值.",
        "optionB": "只要安装成功第三方库,不要导入,就可以直接调用第三方库里的函数.",
        "optionC": "Python 内置的标准函数可以多次调用.",
        "optionD": "函数调用时,如果参数有默认值,就不能给它再赋新的值了.",
        "answer": "C",
        "analyzeContent": "调用函数时不一定是必须要给参数赋值的;先导入第三方库,再调用第三方库里的函数;有默认值的参数也可以赋新值.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11385",
        "version": 3,
        "type": 1,
        "title": "自定义函数的关键字是?( )",
        "optionA": "define",
        "optionB": "del",
        "optionC": "def",
        "optionD": "dfe",
        "answer": "C",
        "analyzeContent": "自定义函数的关键字是 def .",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11386",
        "version": 3,
        "type": 1,
        "title": "下列选项中不能作为自定义函数名的是?( )",
        "optionA": "Int",
        "optionB": "_int2",
        "optionC": "str2int",
        "optionD": "2_int",
        "answer": "D",
        "analyzeContent": "函数名不能以数字开头.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11387",
        "version": 3,
        "type": 1,
        "title": "函数定义如下: def func(a,b=0,c=0): pass 下列选项调用错误的是?( )",
        "optionA": "func(1)",
        "optionB": "func(1)",
        "optionC": "func(1, ,3)",
        "optionD": "func(1,2,3)",
        "answer": "C",
        "analyzeContent": "C 选项中连续输入了两个逗号,解释器会报语法错误.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11388",
        "version": 3,
        "type": 1,
        "title": "下列选项中,函数定义错误的是?( )",
        "optionA": "def afunc(a,b=2):",
        "optionB": "def bfunc(a,b):",
        "optionC": "def cfunc(a,*b):",
        "optionD": "def dfunc(*a,b):",
        "answer": "D",
        "analyzeContent": "可变参数必须在不可变参数的后面.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11389",
        "version": 3,
        "type": 1,
        "title": "运行下列代码,输出结果为?( ) def func(a,b,*args): print(a) print(b) print(args) func(1,2,3,4,5,6)",
        "optionA": "1,2,3,4,5,6",
        "optionB": "1 2 (3,4,5,6)",
        "optionC": "1 2 [3,4,5,6]",
        "optionD": "1 2 3,4,5,6",
        "answer": "B",
        "analyzeContent": "a,b 是位置参数,所以 a=1,b=2, 其余的参数会被 *args 收集打包放进一个元组中,即( 3 , 4 , 5 , 6 ).",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11390",
        "version": 3,
        "type": 1,
        "title": "下列关于函数的说法正确的是?( )",
        "optionA": "一个函数在同一个程序中最多只能被调用 999 次",
        "optionB": "一个函数在同一个程序中最多只能被调用 999 次",
        "optionC": "使用 Python 内置模块里的函数时,要先导入该模块到当前文件中",
        "optionD": "用没有参数的函数时可以不带圆括号",
        "answer": "C",
        "analyzeContent": "函数的调用次数没有限制, A 错误;函数的返回值可以赋值给变量, B 错误;调用没有参数的函数时,函数名后面也要跟一对圆括号, D 错误.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念,自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11391",
        "version": 3,
        "type": 1,
        "title": "下列选项中,不是函数的是?( )",
        "optionA": "max()",
        "optionB": "input()",
        "optionC": "string()",
        "optionD": "sum()",
        "answer": "C",
        "analyzeContent": "Python 中 string 为模块",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11392",
        "version": 3,
        "type": 3,
        "title": "计算下面这段程序的时间复杂度为平方阶: O ( n^2 ).( ) sum1=0 for i in range(101): sum1+=i",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "时间复杂度为线性阶,计 O ( n ).",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "时间复杂度与空间复杂度",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11393",
        "version": 3,
        "type": 3,
        "title": "汉诺塔游戏是递归调用的经典案例.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "汉诺塔是学习递归算法最为常见的例子.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11394",
        "version": 3,
        "type": 3,
        "title": "递推关系是递归的重要组成.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "递推关系是递归的重要组成.( )",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11395",
        "version": 3,
        "type": 3,
        "title": "以下命令: pip get pandas 用于下载第三方库 pandas ,但不马上安装.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "没有 get 这个命令.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11396",
        "version": 3,
        "type": 3,
        "title": "使用 Python 语言编程,可以定义一个名叫 pass 的函数.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "pass 是保留字.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11397",
        "version": 3,
        "type": 3,
        "title": "函数中没有 return 语句或者 return 语句不带任何返回值,那么该函数的返回值为 True .",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "返回值为 None",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的返回值",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11398",
        "version": 3,
        "type": 3,
        "title": "在 Python 中调用函数的时候,必须将每个实参都关联到函数定义中的每一个形参,最简单的关联方式就是基于实参的顺序.但也可以通过关键字实参的\"关键字 - 值\"方式关联形参,这时就不必考虑函数调用过程中实参的顺序.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "形参和实参",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11399",
        "version": 3,
        "type": 3,
        "title": "在 Python 中,全局变量名和局部变量名一定不能重名.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "全局变量名和局部变量名可以是相同的变量名.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11400",
        "version": 3,
        "type": 3,
        "title": "调用函数时, Python 将形式参数传递给实际参数.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "调用函数时, Python 将实际参数传递给形式参数.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "形参和实参",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11401",
        "version": 3,
        "type": 3,
        "title": "分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题,这些子问题相互独立且与原问题性质相同.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题,这些子问题相互独立且与原问题性质相同.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11402",
        "version": 3,
        "type": 4,
        "title": "从键盘接收一组不重复整数,并将这组整数按从小到大的顺序排列. 以下程序采取快速排序法对这组整数进行排序. 快速排序法的原理是: ( 1 )取这组数据中间那个数为锚定值 mid ; ( 2 )从这组数据开头往右找,遇到比 mid 大的数则停下,位置记为 i ; ( 3 )从这组数据末尾往左找,遇到比 mid 小的数则停下,位置记为 j ; ( 4 )如果此时 i 仍在 j 左边,即 i<=j ,则交换这两个数; ( 5 )重复( 2 ) ~ ( 4 )直到 i , j 重合; ( 6 )对 i 左边的数进行快速排序; ( 7 )对右边的数进行快速排序. 输入示例: 请输入需要排序的一组整数,数与数之间用空格隔开: 6 10 11 8 4 1 9 7 输出示例: 排序结果: 1 4 6 7 8 9 10 11 程序模板: def QuickSort(left,right): if ① : return mid=Numbers[left+(right-left)//2] i=left j=right while i<j: while Numbers[i]<mid: i+=1 while Numbers[j]>mid: j-=1 if i<=j: ② QuickSort(left,j-1) QuickSort(i+1,right) Numbers=list(map(int,input(\" 请输入需要排序的一组整数,数与数之间用空格隔开: \"). ③ )) QuickSort(0, ④ ) print(\" 排序结果: \",end=\"\") for i in Numbers: print(i,end=\" \")",
        "answer": "<p class=\"MsoNormal\"><span><font face=\"Calibri\">def QuickSort(left,right):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; if&nbsp;left&gt;=right:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; return</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; mid=Numbers[left+(right-left)//2]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; i=left</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; j=right</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; while i&lt;j:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; while Numbers[i]&lt;mid:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i+=1</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; while Numbers[j]&gt;mid:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-=1</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; if i&lt;=j:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Numbers[i],Numbers[j]=Numbers[j],Numbers[i]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; QuickSort(left,j-1)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; QuickSort(i+1,right)&nbsp;</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">Numbers=list(map(int,input(\"</font><font face=\"宋体\">请输入需要排序的一组整数,数与数之间用空格隔开:</font><font face=\"Calibri\">\").split()))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">QuickSort(0,len(Numbers)-1)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print(\"</font><font face=\"宋体\">排序结果:</font><font face=\"Calibri\">\",end=\"\")</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">for i in Numbers:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; print(i,end=\" \")</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "( 1 ) left>=right ;( 2 分) ( 2 ) Numbers[i],Numbers[j]=Numbers[j],Numbers[i] ;( 2 分) ( 3 ) split() ;( 2 分) ( 4 ) len(Numbers)-1 .( 2 分)",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11403",
        "version": 3,
        "type": 4,
        "title": "鸡兔同笼是中国古代的数学名题之一.大约在 1500 年前,<孙子算经>中就记载了这个有趣的问题.书中是这样叙述的: 今有雉兔同笼,上有三十五头,下有九十四足,问雉兔各几何? 意思是:有若干只鸡兔同在一个笼子里(笼中最少有一只鸡和一只兔),从上面数,有 35 个头,从下面数,有 94 只脚.问笼中各有多少只鸡和兔? 今天我们用编程的方法来求解一下这道数学命题吧. def ji_tu(head,leg): j=0 t=0 while j<head: j += 1 t = ① if (leg== ② ): print(' 有鸡 {} 只,有兔子 {} 只. '.format( ③ )) return (j,t) while True: try: sum_head=int(input(' 请输入总头数: ')) sum_leg=int(input(' 请输入总脚数: ')) if ④ : print(' 输入鸡和兔子的总头数或总脚数错误,请重新输入! ') else: ji_tu( ⑤ ) except: print(' 能不能正常输入数据? ')",
        "answer": "<p class=\"MsoNormal\"><span>参考程序:</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def ji_tu(head,leg):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; j=0</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; t=0</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; while j&lt;head:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; j += 1</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; t =&nbsp;head-j</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; if (leg==(j*2+t*4)):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=\"宋体\">有鸡</font><font face=\"Calibri\">{}</font><font face=\"宋体\">只,有兔子</font><font face=\"Calibri\">{}</font><font face=\"宋体\">只.</font><font face=\"Calibri\">'.format(j,t))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; return (j,t)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">while True:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; try:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; sum_head=int(input('</font><font face=\"宋体\">请输入总头数:</font><font face=\"Calibri\">'))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; sum_leg=int(input('</font><font face=\"宋体\">请输入总脚数:</font><font face=\"Calibri\">'))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; if&nbsp;sum_head&lt;2 or sum_leg&lt;6:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=\"宋体\">输入鸡和兔子的总头数或总脚数错误,请重新输入!</font><font face=\"Calibri\">')</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; else:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ji_tu(sum_head,sum_leg)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; except:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=\"宋体\">能不能正常输入数据?</font><font face=\"Calibri\">')</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "( 1 ) head-j ; (2 分 ) ( 2 ) (j*2+t*4) ; (3 分 ) ( 3 ) j,t ; (2 分 ) ( 4 ) sum_head<2 or sum_leg<6 ; (3 分 ) ( 5 ) sum_head,sum_leg . (2 分 )",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "11404",
        "version": 3,
        "type": 4,
        "title": "有一个游戏:有两个人,第一个人先从 1 和 2 中挑一个数字,第二个人可以在对方的基础上选择加 1 或者加 2 ,然后又轮到第一个人,他也可以选择加 1 或者加 2 , 之后再把选择权交给对方,就这样双方交替地选择加 1 或者加 2 ,谁先加到 20 ,谁就赢了.在不考虑谁输谁赢的情况下,从一开始(以 1 或 2 为起点)加到 20 , 有多少种不同的递加过程?比如 1 , 4 , 7 , 10 , 12 , 15 , 18 , 20 算一种; 2 , 5 , 8 , 11 , 14 , 17 , 20 又是一种.那么一共会有多少种这样的过程呢? 我们可以用递归算法来解决这个问题,请补全代码. def guo_cheng(n): if ① : return 1 return ② # 输出所有过程的个数 print (guo_cheng( ③ ))",
        "answer": "<p class=\"MsoNormal\"><span>参考程序:</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def guo_cheng(n):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; if&nbsp;n==1 or n==2:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; &nbsp; &nbsp; return 1</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp; &nbsp; return&nbsp;guo_cheng(n-1)+guo_cheng(n-2)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">&nbsp;</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\"># </font><font face=\"宋体\">输出所有过程的个数</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print (guo_cheng(20))</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "( 1 ) n==1 or n==2 ; (3 分 ) ( 2 ) guo_cheng(n-1)+guo_cheng(n-2) ; (4 分 ) ( 3 ) 20 . (3 分 )",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      }
    ],
    "calculatePercentage": 0.0,
    "completeTime": "1",
    "answerScore": 0.0,
    "title": "202212Python四级真题",
    "averageScore": 14
  },
  "code": 200,
  "msg": "操作成功"
}