{
  "data": {
    "averageCompleteTime": 644.0,
    "subjectList": [
      {
        "id": "10000",
        "version": 4,
        "type": 1,
        "title": "考察以下函数定义代码: def func(x:int,y:str)->str: z=x*y return z 以下陈述正确的是?( )",
        "optionA": "Python是一种动态类型语言,不强制要求指定参数类型,上述代码行是不符合Python语法的",
        "optionB": "为提高程序的可靠性,Python函数定义时允许为形参指定数据类型,也允许为返回值指定类型",
        "optionC": "由于为函数指定了返回值类型,变量z一定要做类型转换后,才能用于上述return语句中",
        "optionD": "由于为形参指定了不同的数据类型,变量x和y也需要先做类型转换后才能进行上述运算",
        "answer": "B",
        "analyzeContent": "Python不强制要求指定参数类型,但是为提高程序的可靠性,Python函数定义时允许为形参指定数据类型,也允许为返回值指定类型.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9976",
        "version": 0,
        "type": 1,
        "title": "用枚举算法求解\"100以内既能被3整除又能被4整除的元素\"时,在下列数值范围内,算法执行效率最高的是?( )",
        "optionA": "1~101",
        "optionB": "4~100",
        "optionC": "12~100",
        "optionD": "12~96",
        "answer": "D",
        "analyzeContent": "在选取循环控制变量时,枚举范围应尽可能小,但又不能遗漏.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "算法优化",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9977",
        "version": 0,
        "type": 1,
        "title": "下列有关函数的描述中,正确的是?( )",
        "optionA": "函数中必须有return语句",
        "optionB": "在函数内部不能使用全局变量",
        "optionC": "函数能提高应用的模块化程度和代码的重复利用率",
        "optionD": "函数内容以大括号起始,并且缩进",
        "answer": "C",
        "analyzeContent": "函数能提高应用的模块化程度和代码的重复利用率",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9978",
        "version": 0,
        "type": 1,
        "title": "下列哪个语句能够定义参数个数不确定的函数?( )",
        "optionA": "hs(parameters)",
        "optionB": "hs(parameters[])",
        "optionC": "hs(parameters{})",
        "optionD": "hs(*parameters)",
        "answer": "D",
        "analyzeContent": "当不确定需要传入的值是多少个时,在定义形参时,可以使用*parameters来表示.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9979",
        "version": 0,
        "type": 1,
        "title": "执行如下Python代码的结果是?( ) def area(r,pi=3.14): return r*r*pi print(area(2,10))",
        "optionA": "40",
        "optionB": "200",
        "optionC": "400",
        "optionD": "20",
        "answer": "A",
        "analyzeContent": "函数运行结果,2*2*10,结果是40.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9980",
        "version": 0,
        "type": 1,
        "title": "执行如下Python代码,输出结果是?( ) def hs(num): num += 1 return num n=10 s=hs(n) print(s)",
        "optionA": "11",
        "optionB": "10",
        "optionC": "1",
        "optionD": "运行错误",
        "answer": "A",
        "analyzeContent": "函数的返回值,赋值给变量s,输出11.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的返回值",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9981",
        "version": 0,
        "type": 1,
        "title": "有如下Python程序,输出的结果是?( ) def whao(year = '2023'): print('你好' + year) whao()",
        "optionA": "你好",
        "optionB": "你好2023",
        "optionC": "你好year",
        "optionD": "没有输出",
        "answer": "B",
        "analyzeContent": "调用函数whao,输出: 你好2023",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9982",
        "version": 0,
        "type": 1,
        "title": "编写计算正方体体积的匿名函数,下列哪一个语句是正确的?( )",
        "optionA": "rst = lambda a : a * 3",
        "optionB": "lambda a : a * 3",
        "optionC": "rst = lambda a : a ** 3",
        "optionD": "lambda a : a ** 3",
        "answer": "C",
        "analyzeContent": "关键字lambda表示匿名函数,冒号之前表示的是这个函数的参数,冒号之后表示的是返回值,在定义匿名函数时,需要将它赋值给一个变量.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "匿名函数",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9983",
        "version": 0,
        "type": 1,
        "title": "执行如下Python程序,运行的结果是?( ) def zfzh(s): c = '' for ch in s: if \"9\">=ch>= \"0\": c+=str(int(ch)+1) elif \"z\">=ch>= \"a\": c+= chr(ord(ch)- ord(\"a\")+ord(\"A\")) return c s = 'hzag-21-8' print(zfzh(s))",
        "optionA": "HZAG329",
        "optionB": "923HZAG",
        "optionC": "GAZH329",
        "optionD": "923GAZH",
        "answer": "A",
        "analyzeContent": "调用函数zfzh,注意字符串累加方式.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9984",
        "version": 0,
        "type": 1,
        "title": "在Python中,以下哪个代码是安装numpy模块的方法?( )",
        "optionA": "pip install numpy",
        "optionB": "pip uninstall numpy",
        "optionC": "install numpy",
        "optionD": "setup numpy",
        "answer": "A",
        "analyzeContent": "可以安装numpy模块的命令:pip install numpy",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9985",
        "version": 0,
        "type": 1,
        "title": "在Python中导入第三方库的主要关键字是?( )",
        "optionA": "from",
        "optionB": "import",
        "optionC": "pip",
        "optionD": "install",
        "answer": "B",
        "analyzeContent": "在Python中导入第三方库的关键字是import.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9986",
        "version": 0,
        "type": 1,
        "title": "<阅微草堂笔记>里描述了槐树果实\"响豆\",在夜里爆响,这种豆一棵树只有一粒,难以辨认出.所以古人就等槐树开花结果后,用许多布囊分别贮存豆荚,用来当枕头.夜里如果没有听到声音,便扔掉.如果有爆响声.然后把这一囊的豆荚又分成几个小囊装好,夜里再枕着听......如此这么分下去直到找到响豆.以上故事体现的算法是?( )",
        "optionA": "顺序查找",
        "optionB": "枚举算法",
        "optionC": "解析算法",
        "optionD": "分治算法",
        "answer": "D",
        "analyzeContent": "分治算法的特征之一,就是将一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9987",
        "version": 0,
        "type": 1,
        "title": "下列哪项不是分治算法所具有的特征?( )",
        "optionA": "求解问题的规模缩小到一定的程度就能够容易地解决",
        "optionB": "求解题可以分解为若干个规模较小的不同问题",
        "optionC": "利用求解问题分解出的子问题的解可以合并为该问题的解",
        "optionD": "求解问题所分解出的各个子问题是相互独立的",
        "answer": "B",
        "analyzeContent": "求解问题可以分解为若干个规模较小的相同问题.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9988",
        "version": 0,
        "type": 1,
        "title": "两位同学玩猜数字游戏,规则如下:一方在心里默想一个范围在1-100之间的数,如果另一方猜的数字比对方想的要大,就说大了;如果猜的数字比想的要小,就说小了,直到猜中数字.那么使用二分查找法最多需要猜测的次数是?( )",
        "optionA": "10",
        "optionB": "8",
        "optionC": "7",
        "optionD": "6",
        "answer": "C",
        "analyzeContent": "相当于用二分法在1-100之间查找某个数字.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9989",
        "version": 0,
        "type": 1,
        "title": "用递推算法求解n个自然数的乘积,请问代码中横线上需要填入的正确代码是?( ) def fact(n): s=1 for i in range(1,n+1): s=s*i return ________ a=fact(5) print(a)",
        "optionA": "s",
        "optionB": "i",
        "optionC": "fact(n-1)",
        "optionD": "fact(n)",
        "answer": "A",
        "analyzeContent": "def fact(n): s=1 for i in range(1,n+1): s=s*i return s a=fact(5) print(a)",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9990",
        "version": 0,
        "type": 1,
        "title": "一球从100米高度自由落下,每次落地后反跳回原高度的一半;再落下,求它在第10次落地时,共经过多少米?第10次反弹多高? 可以用下列代码解决这个问题,请问这段代码是基于( )算法编写的? high=100 s=0 sum=0 for i in range(10): s,high=high+high/2,high/2 sum=sum+s sum=sum-high print(sum) print(high)",
        "optionA": "递归",
        "optionB": "枚举",
        "optionC": "递推",
        "optionD": "二分",
        "answer": "C",
        "analyzeContent": "递推按照一定的规律来计算序列中的第一项,而问题显然是一个等比数列,可以用递推来解决.代码中没有调用自身的情况,所以不是递归.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9991",
        "version": 0,
        "type": 1,
        "title": "用递归算法求1~n个连续自然数的乘积的代码如下,请选择合适的代码补全程序?( ) def Chengji(n): if n <=1: return 1 else: return _____?______ print(Chengji(3))",
        "optionA": "n*Chengji(n)",
        "optionB": "n*Chengji(n-1)",
        "optionC": "n*Chengji(n+1)",
        "optionD": "n×Chengji(n-1)",
        "answer": "B",
        "analyzeContent": "def Chengji(n): if n <=1: return 1 else: return n*Chengji(n-1) print(Chengji(3))",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9992",
        "version": 0,
        "type": 1,
        "title": "有一根绳子,第一次剪去一半多2米,第二次剪去剩下的一半多2米,第三次剪去剩下的一半多2米,第四次剪去剩下的一半多2米,第五次剪去剩下的一半多2米,此时绳子还剩2米.这根绳子长几米?想解决这个问题的话,可以采用以下哪种算法?( )",
        "optionA": "排序",
        "optionB": "递推",
        "optionC": "解析",
        "optionD": "枚举",
        "answer": "B",
        "analyzeContent": "题目中的绳子长度是按相同的规律剪掉的,所以从后向前,可以按照这个规律来递推计算绳子的长度.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9993",
        "version": 0,
        "type": 1,
        "title": "小猴子第一天摘下若干桃子,当即吃掉一半,又多吃一个.第二天早上又将剩下的桃子吃一半,又多吃一个.以后每天早上吃前一天剩下的一半另加一个.到第5天早上猴子想再吃时,发现只剩下一个桃子了.问第一天猴子共摘多少个桃子? 这个问题可以用递归来解决,代码如下: def peach(day): if day==1: return 1 return (peach(day-1) + 1)*2 s=peach(5) print('一共有%d只桃子'%(s)) 请问第2行的\"if day == 1\"代码起到的作用是?( )",
        "optionA": "结束递归的边界条件",
        "optionB": "开始递归的边界条件",
        "optionC": "调用自身",
        "optionD": "递归过程中的变化",
        "answer": "A",
        "analyzeContent": "递归算法有明确的结束递归的边界条件(又称终止条件)以及结束时的边界值,可以通过条件语句(if语句)实现.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9994",
        "version": 0,
        "type": 1,
        "title": "下列代码可以求两个数的最小公倍数.请认真阅读下列代码运用了什么算法?( ) def lcm(s,m,n): if s%n==0: return s else: return lcm(s+m,m,n) a=int(input('请输入第1个数:')) b=int(input('请输入第2个数:')) c=lcm(a,a,b) print('{}和{}的最小公倍数是{}'.format(a,b,c))",
        "optionA": "枚举",
        "optionB": "解析",
        "optionC": "递归",
        "optionD": "二分",
        "answer": "C",
        "analyzeContent": "在定义一个函数或过程时,如果出现调用自身的成分,则称为递归.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9995",
        "version": 0,
        "type": 1,
        "title": "关于函数,正确的描述是?( )",
        "optionA": "规范的函数设计都应该带有返回值",
        "optionB": "函数体中,只要遇到break关键字,函数就结束",
        "optionC": "函数体中,只要遇到return关键字,函数就结束",
        "optionD": "函数的返回值只能是整型,浮点型,布尔型和字符串",
        "answer": "C",
        "analyzeContent": "Python函数中,一旦遇到return关键字,函数就结束运行.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9996",
        "version": 0,
        "type": 1,
        "title": "关于全局变量和局部变量,正确的描述是?( )",
        "optionA": "通俗来说,无缩进的变量都是全局变量",
        "optionB": "函数体中,只能使用局部变量",
        "optionC": "Python程序中,全局变量与局部变量不允许重名",
        "optionD": "函数体中,只能通过实参传递的方式实现对全局变量数值的使用",
        "answer": "A",
        "analyzeContent": "无缩进的变量都在最上层,是全局变量.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9997",
        "version": 0,
        "type": 1,
        "title": "定义以下函数: def func(x,y,z=2): print(x+y+z) 分别以func(1,2,3)和func(1,2)语句调用该函数,运行后的结果分别是?( )",
        "optionA": "6;出错",
        "optionB": "5;出错",
        "optionC": "5;5",
        "optionD": "6;5",
        "answer": "D",
        "analyzeContent": "Python中,形参设定了默认值后,在调用函数时还可以为该形参再传入新值.func(1,2,3)的值是6,func(1,2)的值是5.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9998",
        "version": 0,
        "type": 1,
        "title": "在嵌套函数中,也就是一个函数里面还有一个函数,如果内部函数需要修改外部变量的值,处理的方法是?( )",
        "optionA": "只能通过不定长参数传递来实现",
        "optionB": "使用local关键字",
        "optionC": "使用nonlocal关键字",
        "optionD": "使用global关键字",
        "answer": "D",
        "analyzeContent": "Python嵌套函数中,如果内部函数需要修改外部变量的值,要使用global关键字.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "9999",
        "version": 0,
        "type": 1,
        "title": "在自定义函数中,如果发现局部变量与全局变量同名,则?( )",
        "optionA": "程序会出现语法错,不能运行",
        "optionB": "程序可以运行,局部变量与全局变量互不干扰",
        "optionC": "可能会出现局部变量修改全局变量的值的情况,需要检查程序设计是否合理",
        "optionD": "不允许出现这种情况,应该采用参数传递的方法去解决问题",
        "answer": "B",
        "analyzeContent": "在Python函数中,如果局部变量与全局变量同名,则局部变量屏蔽全局变量.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10169",
        "version": 4,
        "type": 3,
        "title": "函数是将实现相同功能的代码封装在一起,实现代码复用.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "函数是将实现相同功能的代码封装在一起,实现代码复用.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10170",
        "version": 4,
        "type": 3,
        "title": "关键字实参通过\"关键字=值\"的方式传值,函数参数全部采用此方式传值时,不需要考虑函数调用过程中形参的顺序.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "函数的概念.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10171",
        "version": 4,
        "type": 3,
        "title": "函数的定义代码不需要在主程序调用函数之前.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "函数必须先定义才能调用.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10172",
        "version": 4,
        "type": 3,
        "title": "命令 pip download < 第三方库 > 表示下载并安装指定的第三方库.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "该命令为下载但不安装.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10173",
        "version": 4,
        "type": 3,
        "title": "二分查找又称对折半查找,例如:在数列 34 , 17 , 25 , 9 , 10 , 3 中查找 3 ,适合采用二分查找法.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "二分查找是一种应用于有序数列的高效查找算法.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10174",
        "version": 4,
        "type": 3,
        "title": "递归算法不涉及高深的数学知识,使得很多比较复杂的问题,也可以用简洁的代码解决,代码的执行效率比较高,所以即使有其他算法可行,也应该首选递归算法解决问题.( )",
        "optionA": "递归算法代码运行时会引起一系列函数调用,有不少重复计算,其执效率比较低.",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "递归算法代码运行时会引起一系列函数调用,有不少重复计算,其执效率比较低.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10175",
        "version": 4,
        "type": 3,
        "title": "递归算法中,必然存在函数体内调用自身的情况,可以在最后调用,也可以在中间调用.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "在定义一个函数或过程时,如果出现调用自身的成分,则称为递归.调用自身的位置根据具体情况而定,不强制要求在最后才能调用自身.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10176",
        "version": 4,
        "type": 3,
        "title": "Python 程序中,自定义函数可以放在整个程序的开头,也可以放在主程序之后,比较自由.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "Python程序中,自定义函数要放在主程序之前.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10177",
        "version": 4,
        "type": 3,
        "title": "通过把某些特定功能语句设计成自定义函数,可以简化主程序的编写.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "通过函数调用,可以简化主程序的编写.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10178",
        "version": 4,
        "type": 3,
        "title": "下面代码的时间复杂度为 O(n*n) .( ) arr = [ 2, 3, 4, 10, 40 ] n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1] : arr[j], arr[j+1] = arr[j+1], arr[j]",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "双重循环,时间复杂度为 O(n*n) .",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "时间复杂度与空间复杂度",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10179",
        "version": 4,
        "type": 4,
        "title": "从键盘上分别输入要查找和替换的字符串,对文本文件进行查找与替换,替换后保存到新的文本文件中. 思路:输入待查找字符串 s ,需查找子字符串 key 和替换字符串 new ,通过调用自定义函数 replace 实现替换.完善划线处代码. s = input(\" 请输入待查找的字符串: \") key = input(\" 请输入需查找的子字符串: \") new = input(\" 请输入要替换的字符串: \") def findstr(key, s, begin): for i in range(begin,len(s) - len(key) + 1): if s[i: ① ]== key: return i return -1 def replace(key, new, s): begin = 0 while begin < ② : pos = findstr(key,s, begin) if pos ==-1: break else: s = s[0:pos]+ new + s[pos + len(key): ③ ] begin =  pos + len(key) return s rst = ④ # 调用函数替换字符 print(rst)",
        "answer": "<p class=\"MsoNormal\"><span><font face=\"Calibri\">s = input(\"</font><font face=\"宋体\">请输入待查找的字符串:</font><font face=\"Calibri\">\")</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">key = input(\"</font><font face=\"宋体\">请输入需查找的子字符串:</font><font face=\"Calibri\">\")</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">new = input(\"</font><font face=\"宋体\">请输入要替换的字符串:</font><font face=\"Calibri\">\")</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def findstr(key, s, begin):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">for i in range(begin,len(s) - len(key) + 1):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">if s[i:i+len(key)]== key:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return i &nbsp;</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return -1</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def replace(key, new, s):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">begin = 0</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">while begin &lt; len(s)-len(key)+ 1:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">pos = findstr(key,s, begin)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">if pos ==-1:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">break</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">else:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">s = s[0:pos]+ new + s[pos + len(key):len(s)]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">begin = pos + len(key)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return s</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">rst = replace(key,new,s) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=\"宋体\">调用函数替换字符</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print(rst)</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "评分标准: ( 1 ) i+len(key) 或等价答案;( 3 分 ) ( 2 ) len(s)-len(key)+ 1 或等价答案;( 3 分 ) ( 3 ) len(s) 或等价答案;( 3 分 ) ( 4 ) replace(key,new,s) 或等价答案.( 3 分 )",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10180",
        "version": 4,
        "type": 4,
        "title": "一个列表中存在 n 个数据,可以用分治算法来找到其中的最小值.具体过程如下:如果列表元素的个数小于等于 2 的时候,经过一个判断就找到其中的最小值,所以可以先把数据从中间划分为左右两部分,然后通过递归把每一部分再划分为左右两部分,直到数据规模小于等于 2 的时候,返回结果,然后通过递归到最后为两个数据对比,我们就可以找到最小值. 请根据以上算法过程,补全代码. # 求列表中小于两个元素的最小值 def get_min(number): if len(number) == 1: return ① else: if number[1] > number[0]: return number[0] else: return number[1] def solve(number): n = len(number) if n <= 2: return get_min(number) else: # 将整个列表分为左右两部分 left_list, right_list = ② , number[n//2:] # 递归(树),分治 left_min, right_min = solve(left_list), ③ return get_min([left_min, right_min]) test_list = [5, 11, 3, 2, 7, 9] print(solve(test_list))",
        "answer": "<p class=\"MsoNormal\"><span>参考程序:</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\"># </font><font face=\"宋体\">求列表中小于两个元素的最小值</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def get_min(number):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">if len(number) == 1:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return number[0]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">else:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">if number[1] &gt; number[0]:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return number[0]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">else:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return number[1]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">def solve(number):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">n = len(number)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">if n &lt;= 2:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return get_min(number)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">else:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\"># </font><font face=\"宋体\">将整个列表分为左右两部分</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">left_list, right_list = number[:n//2], number[n//2:]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\"># </font><font face=\"宋体\">递归(树),分治</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">left_min, right_min = solve(left_list), solve(right_list)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">return get_min([left_min, right_min])</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">test_list = [5, 11, 3, 2, 7, 9]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print(solve(test_list))</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "评分标准: ( 1 ) number[0] ;( 2 分 ) ( 2 ) number[:n//2] ;( 3 分 ) ( 3 ) solve(right_list) .( 3 分 )",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10181",
        "version": 4,
        "type": 4,
        "title": "未来居民社区设计有一个机器人服务中心,假如某社区有若干栋住宅楼,每栋楼的位置可以由坐标 (x,y) 表示,其中 x 坐标表示居民楼的东西向位置, y 坐标表示居民楼的南北向位置.这里约定,社区中任意 2 点 (x1,y1) 和 (x2,y2) 的之间的距离使用数值 |x1-x2|+|y1-y2| 来度量.要求为社区选择建立机器人服务中心的最佳位置,使各个居民点到机器人服务中心的距离总和最小.以下是机器人服务中心的选址程序,采用取各坐标中位数的方法来确定中心位置,请补充完成该程序. 注:中位数的含义:一组按大小顺序排列起来的数据中处于中间位置的数.当有奇数个数据时 , 中位数就是中间那个数;当有偶数个数据时 , 中位数就是中间那两个数的平均数. n=int(input(\" 请输入居民楼总数: \")) hx=[] hy=[] for i in range(n): x,y = map(int,input(\" 请输入居民楼的 x 和 y 坐标: \").split(\",\")) hx. append(x) hy. append(y) hx = sorted( ① ) hy = sorted( ② ) if n%2 == 0:  # 偶数情况,求中位数 sn = int(n/2) x0 = int((hx[sn]+hx[sn-1])/2) y0 = int((hy[sn]+hy[sn-1])/2) else:         # 奇数情况,求中位数 sn = int((n-1)/2) x0 = ③ y0 = ④ sumx=0 sumy=0 for j in hx: dx =abs(x0-j) sumx += dx for k in hy: dy = abs(y0-k) sumy += dy print(\" 选址点的坐标是: (%d,%d)\"%(x0,y0)) print(\" 选址到各楼的累计距离是: \",sumx+sumy)",
        "answer": "<p class=\"MsoNormal\"><span>参考程序:</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">n=int(input(\"</font><font face=\"宋体\">请输入居民楼总数:</font><font face=\"Calibri\">\"))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">hx=[]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">hy=[]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">#x,y = input(\"</font><font face=\"宋体\">请输入居民楼的</font><font face=\"Calibri\">x</font><font face=\"宋体\">和</font><font face=\"Calibri\">y</font><font face=\"宋体\">坐标:</font><font face=\"Calibri\">\").split(\",\")</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">for i in range(n):</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">x,y = map(int,input(\"</font><font face=\"宋体\">请输入居民楼的</font><font face=\"Calibri\">x</font><font face=\"宋体\">和</font><font face=\"Calibri\">y</font><font face=\"宋体\">坐标:</font><font face=\"Calibri\">\").split(\",\"))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">hx.append(x)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">hy.append(y)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">hx=sorted(hx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=\"宋体\">对输入坐标进行排序</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">hy=sorted(hy)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">if n%2 == 0: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=\"宋体\">偶数情况,求中位数</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">sn = int(n/2)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">x0 = int((hx[sn]+hx[sn-1])/2)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">y0 = int((hy[sn]+hy[sn-1])/2)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">else: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=\"宋体\">奇数情况,求中位数</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">sn = int((n-1)/2)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">x0 = hx[sn]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">y0 = hy[sn]</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">sumx=0</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">sumy=0</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">for j in hx:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">dx =abs(x0-j)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">sumx += dx</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">for k in hy:</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">dy = abs(y0-k)</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Calibri\">sumy += dy</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span>&nbsp;&nbsp;&nbsp;</span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print(\"</font><font face=\"宋体\">选址点的坐标是:</font><font face=\"Calibri\">(%d,%d)\"%(x0,y0))</font></span><span><o:p></o:p></span></p><p class=\"MsoNormal\"><span>&nbsp;</span></p><p class=\"MsoNormal\"><span><font face=\"Calibri\">print(\"</font><font face=\"宋体\">选址到各楼的累计距离是:</font><font face=\"Calibri\">\",sumx+sumy)</font></span><span><o:p></o:p></span></p>",
        "analyzeContent": "评分标准: ( 1 ) hx ;( 2 分 ) ( 2 ) hy ;( 2 分 ) ( 3 ) hx[sn] ;( 3 分 ) ( 4 ) hy[sn] .( 3 分 )",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      }
    ],
    "calculatePercentage": 0.0,
    "completeTime": "1",
    "answerScore": 0.0,
    "title": "202309Python四级真题",
    "averageScore": 20
  },
  "code": 200,
  "msg": "操作成功"
}