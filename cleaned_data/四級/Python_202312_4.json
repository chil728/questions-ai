{
  "data": {
    "averageCompleteTime": 702.0,
    "subjectList": [
      {
        "id": "10307",
        "version": 4,
        "type": 1,
        "title": "下列有关分治算法思想的描述不正确的是?( )",
        "optionA": "将问题分解成的子问题具有相同的模式.",
        "optionB": "将问题分解出的各个子问题相互之间有公共子问题.",
        "optionC": "当问题足够小时,可以直接求解.",
        "optionD": "可以将子问题的求解结果合并成原问题的解.",
        "answer": "B",
        "analyzeContent": "将问题分解出的各个子问题相互之间没有公共子问题.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10308",
        "version": 4,
        "type": 1,
        "title": "斐波那契数列前 n 项是 1,1,2,3,5,8,13...... 补全下面程序代码,求第 n 项斐波那契数列的值. def fib(n): if ______: return 1 else: return fib(n-1) + fib(n-2)",
        "optionA": "n == 2",
        "optionB": "n < 2",
        "optionC": "n == 3",
        "optionD": "n < 3",
        "answer": "D",
        "analyzeContent": "用分治思想,递归求解.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推,分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10309",
        "version": 4,
        "type": 1,
        "title": "用分治法求两个数的最大公约数,代码和运行结果如下,请选择合适的代码完成程序?( ) def fun(m, n): if m % n == 0: return n else: return __________ print(fun(98, 56)) 程序运行结果如下: 14",
        "optionA": "fun(n, m-n)",
        "optionB": "fun(n, m%n)",
        "optionC": "fun(m, m-n)",
        "optionD": "fun(m, m%n)",
        "answer": "B",
        "analyzeContent": "用分治算法,实现两个数的最大公约数求解.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10310",
        "version": 4,
        "type": 1,
        "title": "列出第三方库的详细信息的pip指令是?( )",
        "optionA": "pip install <第三方库名>",
        "optionB": "pip download<第三方库名>",
        "optionC": "pip show<第三方库名>",
        "optionD": "pip list<第三方库名>",
        "answer": "C",
        "analyzeContent": "pip命令",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10311",
        "version": 4,
        "type": 1,
        "title": "想要在 Python中导入math模块中的sqrt(x)函数,下列程序段错误的是?( )",
        "optionA": "import math math.sqrt(x)",
        "optionB": "from math import sqrt as t t(x)",
        "optionC": "from math import sqrt as t t(x)",
        "optionD": "import mathsqrt(x)",
        "answer": "D",
        "analyzeContent": "库使用",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10312",
        "version": 4,
        "type": 1,
        "title": "关于求解\"找出所有满足各位数字之和等于8的三位数\"时,在下列 数值范围内,算法执行效率最高的是?( )",
        "optionA": "0—999",
        "optionB": "0—1000",
        "optionC": "100—800",
        "optionD": "107—800",
        "answer": "D",
        "analyzeContent": "枚举的范围应尽可能小但又不遗漏 .",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "算法优化",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10313",
        "version": 4,
        "type": 1,
        "title": "已知,从1到n的连续自然数相乘的积叫做阶乘,用符号n!表示,比如3!=1×2×3,规定0!=1.那么用递归算法求n的阶乘,递归式正确的是?( )",
        "optionA": "f(0)=1,n=n*(n-1)",
        "optionB": "f(0)=1,f(n)=f(0)*f(n-1)",
        "optionC": "f(0)=1,f(n)=f(n)*f(n-1)",
        "optionD": "f(0)=1,f(n)=n*f(n-1)",
        "answer": "D",
        "analyzeContent": "使用递归求解 n的阶乘 n! = 1 * 2* 3*...*n,这个式子写成递归式就是 n! = (n -1)! * n, 就把问题规模为n的问题转换为求解规模为n -1的问题.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10314",
        "version": 4,
        "type": 1,
        "title": "当 n为6时,运行下列Python程序后的结果是?( ) def f(n): if n<=2: return 1 else: return f(n-1)+f(n-2) n=int(input(\"请输入一个正整数:\")) print(f(n))",
        "optionA": "5",
        "optionB": "8",
        "optionC": "11",
        "optionD": "13",
        "answer": "B",
        "analyzeContent": "递归式看出每一项等于前两项之和,递推得出结果.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10315",
        "version": 4,
        "type": 1,
        "title": "下列程序中,当 n＝4时,返回结果为?( ) def x(n): if  n==1: return 1 else: return n+x(n-1)",
        "optionA": "12",
        "optionB": "11",
        "optionC": "10",
        "optionD": "9",
        "answer": "C",
        "analyzeContent": "根据递归式,对 n求和.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10316",
        "version": 4,
        "type": 1,
        "title": "下列选项中,不属于递归特性的是?( )",
        "optionA": "递归函数一定包含条件控制语句",
        "optionB": "递归算法体现了大事化小的思想",
        "optionC": "递归效率不高,递归层次过多会导致栈溢出",
        "optionD": "递归算法代码简洁,效率较高",
        "answer": "D",
        "analyzeContent": "递归算法必须有结束递归的条件来终止递归,递归过程中进行递归调用的次数必须是有限的,算法效率不高.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10317",
        "version": 4,
        "type": 1,
        "title": "对于下列递归式子,当 n=4时,F的值是?( ) F(n)=F(n-1)*2 F(1)=2",
        "optionA": "2",
        "optionB": "8",
        "optionC": "16",
        "optionD": "32",
        "answer": "C",
        "analyzeContent": "根据递归式,每一项等于前一项乘以 2.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10318",
        "version": 4,
        "type": 1,
        "title": "下面函数实现的功能是?( ) def   mi(x, n): if   n == 0: return  1 else: return  x*mi(x, n-1)",
        "optionA": "计算x的n次方",
        "optionB": "计算n的x次方",
        "optionC": "计算x!*n",
        "optionD": "计算x*n!",
        "answer": "A",
        "analyzeContent": "根据递归式,求x的n次方.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10319",
        "version": 4,
        "type": 1,
        "title": "def afun(n): s=1 for i in range(1,n+1): s*=i return s 对以上代码解释错误的是?( )",
        "optionA": "程序正常运行时, afun(n)函数的作用是求n的阶乘",
        "optionB": "程序正常运行时, afun(n)函数的作用是求n+1的阶乘",
        "optionC": "s是局部变量",
        "optionD": "range()函数是Python内置函数",
        "answer": "B",
        "analyzeContent": "在 range(a,b)函数中,范围包含a,不包含b.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10320",
        "version": 4,
        "type": 1,
        "title": "关于下列代码解释错误的一项是?( ) def ZhongYao(a:str,b:int)->str: word=a*b print('重要的事情说{}遍:{}'.format(b,word)) return ZhongYao ZhongYao('学习','3')",
        "optionA": "参数 a的数据类型必须是字符串",
        "optionB": "参数 b的数据类型必须是整型",
        "optionC": "函数指定了返回值的数据类型是字符串",
        "optionD": "程序正常运行,输出结果是: 重要的事情说 3遍:学习学习学习",
        "answer": "D",
        "analyzeContent": "因为 a的值是'学习',b的值是'3',其数据类型均为字符串, 所以无法运行 word=a*b,故程序会报错.其余三项均正确.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10321",
        "version": 4,
        "type": 1,
        "title": "下列代码的运行结果是?( ) def exchange(a,b): a,b=b,a print(a,b) a,b=3,5 exchange(a,b) print(a,b)",
        "optionA": "5 3 5 3",
        "optionB": "3 53 5",
        "optionC": "3 53 5",
        "optionD": "5 3 3 5",
        "answer": "C",
        "analyzeContent": "函数体内的 a,b是局部变量,函数体外的a,b是全局变量.全 局变量的作用域是整个程序,局部变量的作用域是函数内部.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10322",
        "version": 4,
        "type": 1,
        "title": "下列代码的运行结果是?( ) def car_show(cars): for car in cars: print('good',car) car_show(['BYD','Haval','Wuling'])",
        "optionA": "good ['BYD','Haval','Wuling']",
        "optionB": "'good','BYD' 'good','Haval' 'good','Wuling'",
        "optionC": "good BYD Haval Wuling",
        "optionD": "good BYDgood Havalgood Wuling",
        "answer": "D",
        "analyzeContent": "列表可以做为参数传递进函数体内,并且按列表的语法规则进行读取与修改.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10323",
        "version": 4,
        "type": 1,
        "title": "函数中定义了 4个参数,其中2个参数都指定了默认值,见下面代码,那么在调用函数时 参数个数最少是?( ) def SiBianXing(a,b,c=5,d=8): ZhouChang=a+b+c+d return ZhouChang SiBianXing( ? )",
        "optionA": "0",
        "optionB": "1",
        "optionC": "2",
        "optionD": "3",
        "answer": "B",
        "analyzeContent": "设置了默认值的参数,在函数调用时可以不用传入值,此时采用默认值运行. 如果传入了新值,那么将使用新传入的值运行.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数使用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10325",
        "version": 4,
        "type": 1,
        "title": "执行如下程序,以下选项中哪一项是错误的?( ) def f(a,b): c=a+b*2 b=a return c a=1 b=2 c=f(a,b)+b",
        "optionA": "该函数名称为 f",
        "optionB": "执行该程序后,变量 a的值为1",
        "optionC": "执行该程序后,变量 b的值为2",
        "optionD": "执行该程序后,变量 c的值为6",
        "answer": "D",
        "analyzeContent": "调用时函数返回值局部变量 a=1,b=1,c=5,调用结束后返回主程序, 全局变量 a=1,b=2,c=5+2=7.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10327",
        "version": 4,
        "type": 1,
        "title": "以下哪种情况下的代码块适合设计成函数?( )",
        "optionA": "复杂的功能块",
        "optionB": "难以看懂的功能块",
        "optionC": "有性能要求的功能块",
        "optionD": "会多次用到的功能块",
        "answer": "D",
        "analyzeContent": "函数的根本目的是代码复用.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10330",
        "version": 4,
        "type": 1,
        "title": "使用位置实参的方式调用函数时,下列哪种情况下程序一定会出错?( )",
        "optionA": "传入的实参个数比形参个数多",
        "optionB": "部分形参赋以默认值",
        "optionC": "函数调用时,重新给赋予了默认值的形参传入新值",
        "optionD": "部分实参以关键字赋值的方式去调用函数",
        "answer": "A",
        "analyzeContent": "传入的实参个数要与函数定义时所提供的形参个数匹配.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10332",
        "version": 4,
        "type": 1,
        "title": "下列函数定义中,正确的是?( )",
        "optionA": "def myfunc(a,b,c) print(myfunc(a,b))",
        "optionB": "def myfunc(a=1,b,c): print(myfunc(a,b,c))",
        "optionC": "def myfunc(a,b=1,c): print(myfunc(a,b,c))",
        "optionD": "def myfunc(a,b,c=1): print(myfunc(a,b,c))",
        "answer": "D",
        "analyzeContent": "形参可以有默认值,但是有位置要求.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10334",
        "version": 4,
        "type": 1,
        "title": "调用函数的时候,所使用的参数是?( )",
        "optionA": "实参",
        "optionB": "位置参数",
        "optionC": "关键字参数",
        "optionD": "不定长参数",
        "answer": "A",
        "analyzeContent": "B-C均为形参",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10336",
        "version": 4,
        "type": 1,
        "title": "对于如下自定义的函数: def myfunc(a,b,c): return a+b+c 以下调用该函数的语句中,能正确执行的是?( )",
        "optionA": "myfunc(1,2)",
        "optionB": "myfunc(a=3,2,1)",
        "optionC": "myfunc(3,b=2,1)",
        "optionD": "myfunc(3,2,c=1)",
        "answer": "D",
        "analyzeContent": "在形参列表中必须先列出没有默认值的形参,再列出有默认值的形参.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10337",
        "version": 4,
        "type": 1,
        "title": "使用 *args和**kwargs形参来定义函数时,正确的说法是?( )",
        "optionA": "使用 *args代表列表,使用**kwargs代表元组",
        "optionB": "可以在调用函数时传入多个实参",
        "optionC": "使用 *args代表元组,使用**kwargs代表列表",
        "optionD": "使用 *args代表字典,使用**kwargs代表列表",
        "answer": "B",
        "analyzeContent": "使用 *args和**kwargs形参来定义函数时,使用*args代表列表, 使用 **kwargs代表字典,这种形式可以在调用函数时传入多个实参.",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10338",
        "version": 4,
        "type": 1,
        "title": "关于函数参数的默认值设置,描述不正确的是?( )",
        "optionA": "定义函数时,可以为某形参设定默认值",
        "optionB": "如果为某形参设定了默认值,则在调用函数时就不能再为该形参传入新值",
        "optionC": "如果为某形参设定了默认值,在调用函数时还可以为该形参再传入新值",
        "optionD": "如果为某形参设定了默认值,在调用函数时还可以为该形参再传入新值",
        "answer": "B",
        "analyzeContent": "Python中,形参设定了默认值后,在调用函数时还可以为该形参再传入新值",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10339",
        "version": 4,
        "type": 3,
        "title": "分治算法是把一个大问题分解为若干个规模较小,性质相同的子问题.最后子问题 可以简单地直接求解,将所有子问题的解合并起来就是原问题的解.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "分治算法的概念:分,治,合.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "分治算法",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10340",
        "version": 4,
        "type": 3,
        "title": "pip联网直接下载安装第三方库时,只能临时更换下载源,不能更改默认的下载源.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "pip安装第三方库",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "第三方库(模块)的获取,安装与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10446",
        "version": 4,
        "type": 3,
        "title": "运行以下代码的时间复杂度为O(n 2 ).( ) k=0 n=11 for i in range(n): k=k+1 for j in range(n):",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "两个for语句不为嵌套,那么它们执行的时间复杂度只计算一个的就可以了,所以时间复杂度为O(n).",
        "examDots": "35,",
        "difficultyLevel": "5",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "时间复杂度与空间复杂度",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10447",
        "version": 4,
        "type": 3,
        "title": "对于递归而言,递推与回归,二者缺一不可.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "递推关系是递归的重要组成.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10453",
        "version": 4,
        "type": 3,
        "title": "递归算法必须确保,需要解决的问题可以转化为一个或多个子问题来求解,这些子问题的求解方法与原问题相同,只是在数量和规模上不同,而且每次递归调用时,问题规模都能够缩小.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "递归的核心思想就是自己调用自己,能够用递归解决问题的条件之一,是需要解决的问题可以转化为一个或多个子问题来求解,而这些子问题的求解方法与原问题相同,只是在数量和规模上不同.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "递归与递推",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10455",
        "version": 4,
        "type": 3,
        "title": "当函数运行结束后,局部变量的值依然存在,下次函数调用可以继续使用.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "局部变量的作用域是在函数体内,函数体内的代码运行完毕后,局部变量的值会在内存中被删除,下次函数调用时不能继续使用.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "全局变量和局部变量",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10456",
        "version": 4,
        "type": 3,
        "title": "内置函数不需要使用关键字import导入就可以使用,自定义函数可以先调用后定义.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "自定义函数必须要先定义,才能调用.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "自定义函数的创建与调用",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10457",
        "version": 4,
        "type": 3,
        "title": "编程时,需要把实现复杂功能的代码封装起来,设计成函数.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "程序设计中,可以把需要重复使用的代码封装起来,设计成函数.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10458",
        "version": 4,
        "type": 3,
        "title": "将实现特定功能的代码块设计成函数,有助于提高整个程序的运行速度.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "0",
        "analyzeContent": "函数设计的主要目的是提高代码的复用率,并不提升程序的运行速度.",
        "examDots": "35,",
        "difficultyLevel": "3",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "函数的相关概念",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10459",
        "version": 4,
        "type": 3,
        "title": "如果允许形参设置默认值,则函数定义时要先列出没有默认值的形参,再列出有默认值的形参.( )",
        "optionA": "",
        "optionB": "",
        "optionC": "",
        "optionD": "",
        "answer": "1",
        "analyzeContent": "Python函数,定义时要先列出没有默认值的形参,再列出有默认值的形参.",
        "examDots": "35,",
        "difficultyLevel": "4",
        "weType": 0,
        "isMySubject": 0,
        "knowledgeNames": "形参和实参",
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10465",
        "version": 4,
        "type": 4,
        "title": "统计高分问题 小张在学习对分查找后,想利用该思路来实践一下,加深对该算法的理解.于是他按老师的要求,统计期末考试成绩,总分比他高的同学有多少个? 他的思路是,首先将全区所有学生的成绩降序排序,然后利用对分查找思想解决.他编写的代码如下,请完善划线处的代码. cj =[654,643,621,612,609,606,...] #学生成绩存列表cj并已经降序排序 def dfsearch(key): i =0; j=len(cj)-1 while i<=j: m =(i+j)//2 if cj[m]>key: ① else: j-= 1 return ② key = int(input('输入待查找的成绩')) pos = ③ print('高于 ' ,key,'分的人数有',pos)",
        "answer": "<p><span>标准答案:</span></p><p><span><strong>参考程序:</strong></span></p><p>cj =[654,643,621,612,609,606,...]<span>#学生成绩存列表cj并已经降序排序</span></p><p>def&nbsp;dfsearch(key):<br>&nbsp; &nbsp; &nbsp; &nbsp;i =0; j=len(cj)-1<br>&nbsp; &nbsp; &nbsp;&nbsp;while&nbsp;i&lt;=j:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m =(i+j)//2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;cj[m]&gt;key:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span><strong>&nbsp;i +=1&nbsp; &nbsp;</strong></span>&nbsp;&nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-= 1<br>&nbsp; &nbsp; &nbsp; return&nbsp; &nbsp;<span><strong>&nbsp; &nbsp;i&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong></span><br>key =&nbsp;int(input('输入待查找的成绩'))<br>pos =&nbsp;<span><strong>&nbsp;dfsearch(key)</strong></span><br>print('高于<span>'</span>,key,'分的人数有',pos)&nbsp;</p>",
        "analyzeContent": "评分标准: (1)i += 1或等价表达式;(2分) (2)i或等价表达式;(3分) (3)dfsearch(key)或等价表达式.(3分)",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10467",
        "version": 4,
        "type": 4,
        "title": "比岁数问题 有5个人坐在一起,问第五个人多少岁?他说比第4个人大2岁.问第4个人岁数,他说比第3个人大2岁.问第三个人,又说比第2人大两岁.问第2个人,说比第一个人大两岁. 最后问第一个人,他说是10岁.请问第五个人多大? 请运用递归算法完成以下代码. def age(n): if         ①        : c = 10 else: c =        ② return c print(age(        ③        ))",
        "answer": "<p>参考程序:</p><p><br></p><p>def age(n):</p><p>&nbsp; &nbsp; if n == 1:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; c = 10</p><p>&nbsp; &nbsp; else:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; c = age(n - 1) + 2</p><p>&nbsp; &nbsp; return c</p><p>print(age(5))</p>",
        "analyzeContent": "试题解析: 评分标准: (1)n==1或等效答案;(3分) (2)age(n - 1) + 2或等效答案;(4分) (3)5或等效答案.(3分)",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      },
      {
        "id": "10468",
        "version": 4,
        "type": 4,
        "title": "数学证明问题 上世纪中期,校园里流行一种数学游戏,其规则十分简单:任意取一个自然数,若它是奇数,则把它乘以3加上1,若它是偶数,则除以2.按此规则进行下去,经过若干步的计算就能得到自然数1.这个数学现象至今都没有得到完全的证明,但是可以编程来验证它的正确性. 实现上述功能的部分程序代码如下,请补充完成空白处的内容. step = 1 midlist = [] def subwork(n): global step if n == 1: return step elif n % 2 == 0: n =         ① midlist. append(n) step +=  1 subwork(        ②        ) return step elif n % 2 != 0: n =         ③ midlist.        ④ step +=  1 subwork(        ⑤        ) return step cur_num = int(input(\"请输入一个数字:\")) subwork(cur_num) print(midlist) print(step)",
        "answer": "<p>标准答案:</p><p><br></p><p>参考程序:</p><p><br></p><p>step = 1</p><p><br></p><p>midlist = []</p><p><br></p><p>&nbsp;</p><p><br></p><p>def subwork(n):</p><p><br></p><p>&nbsp; &nbsp; global step</p><p><br></p><p>&nbsp; &nbsp; if n == 1:</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp; &nbsp; elif n % 2 == 0:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; n = n / 2</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; midlist.append(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; step +=&nbsp; 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; subwork(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp; &nbsp; elif n % 2 != 0:</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; n = n * 3 + 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; midlist.append(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; step +=&nbsp; 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; subwork(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp;</p><p><br></p><p>cur_num = int(input(\"请输入一个数字:\"))</p><p><br></p><p>subwork(cur_num)</p><p><br></p><p>print(midlist)</p><p><br></p><p>print(step)</p>",
        "analyzeContent": "评分标准: (1)n / 2或等效答案;(3分) (2)n或等效答案;(2分) (3)n * 3 + 1或等效答案;(3分) (4)append(n)或等效答案;(2分) (5)n 或等效答案.(2分)",
        "examDots": "35,",
        "weType": 0,
        "isMySubject": 0,
        "answerStatus": 0,
        "compileEnvironment": 0
      }
    ],
    "calculatePercentage": 0.0,
    "completeTime": "1",
    "answerScore": 0.0,
    "title": "202312Python四级真题",
    "averageScore": 18
  },
  "code": 200,
  "msg": "操作成功"
}