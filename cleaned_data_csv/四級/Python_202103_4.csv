id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,examDots,difficultyLevel,weType,isMySubject,knowledgeNames,answerStatus,compileEnvironment
3608,0,1,"不超过 100个元素的有序数列,使用二分查找能找到指定的元素,可能的查找次数不包括?",1次,6次,7次,8次,D,"按照二分查找法的规律, 100个元素的有序列表,不管是否找到,至多查找7次.","35,",5,0,0,分治算法,0,0
3609,0,1,"运行以下代码,正确的打印结果是? def f(): c=0 for i in range(4,51,4): if i%6==0: c=c+1 return c print(f())",1,2,4,8,C,"函数 f()的作用是求4-50间4和6的公倍数个数,即12的倍数个数.","35,",4,0,0,函数使用,0,0
3610,0,1,"10个人站一列,分苹果,问第10个人分到多少个苹果,他说比前面一个人多分到2个,依次往前,都说比前面一个人多分到2个,最后问第一个人,他说分到10个苹果.用以下函数求第10个人分到的苹果数,则应补充选项为?( ) def  apple(n): if n == 1: return 10 else: return print(apple(10))",apple(n)+2,n+2,apple(n-1)+2,apple(n+1)-2,C,def  apple(n): if n == 1: return 10 else: return  apple(n-1)+2 print(apple(10)),"35,",4,0,0,递归与递推,0,0
3611,0,1,"观察程序段,以下说法错误的是? def fib(n): if n==1 or n==2: s=1 else: s=fib(n-1)+fib(n-2) return s m=int(input(""请输入m的值(m>2):"")) print(fib(m))","如果输入 m的值为8,打印的结果为20",该程序段用了递归来实现,"如果缺少语句 ""return s"",程序会报错","语句 ""def fib(n):""中的n为形参",A,"定义函数时的语法如下: def 函数名(参数集合): <函数体> [return 函数值] 本题中的自定义函数 fib(m)需要返回值,所以""return 函数值""语句不能少,定义时""函数名<参数集合>""中的参数为形参,调用时""函数名<参数集合>"" 中的参数为实参.如果输入m的值为8,打印的结果为21.","35,",4,0,0,函数的相关概念,0,0
3612,0,1,关于 python函数参数的说法正确的是?,函数一定要有参数和返回值,"在调用一个函数时,若函数中修改了形参变量的值,则对应的实参变量的值也被修改","参数的值是否会改变,与函数中对变量的操作有关,与参数类型无关",函数的形参在函数被调用时获得初始值,D,"函数的形参作用域为本函数,在函数被调用时获得初始值","35,",4,0,0,函数的相关概念,0,0
3613,0,1,"关于递归与递推方法的比较,错误的观点是?","递归是将复杂问题降解成若干个子问题,依次降解,求出低阶规模的解,代入高阶问题中,直至求出原问题的解;","递推是构造低阶的问题,并求出解,依次推导出高阶的问题以及解,直至求出问题的解;",数学上的递推关系可以通过递归的方法来实现;,"递归算法代码简洁,运行速度比递推快,因此应该尽量采用递归的方法;",D,D.递归的运行开销大.,"35,",4,0,0,递归与递推,0,0
3614,0,1,"运行以下代码,输出结果正确的是? a=1 b=c=[] def fun(a,c): a=2 c.append(a) fun(a,c) print(a,b,c)",2 [2] [2],1 [] [2],1 [2] [2],2 [] [2],C,"函数体内变量 a的值为2,添加到了列表c中,b和c指向同一个列表地址,因此列表b也随之改变","35,",4,0,0,函数的相关概念,0,0
3615,0,1,"关于 Turtle库的表述中,错误的是?",Turtle库是Python语言中一个很流行的绘制图像的函数库.,"画布就是 turtle为我们展开用于绘图区域,我们可以设置它的大小和初始位置.",turtle.circle( )是只能画一个指定半径为r的圆.,"turtle.speed(speed):设置画笔移动速度,画笔绘制的速度范围[0,10]整数,数字越大越快",C,"turtle.circle( )是turtle中的常用命令,基本语法是circle(radius,e),即画一个指定半径为r,角度e的圆或弧","35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
3616,0,1,"有 100枚金币,其中有1枚轻1克的假金币,现在要找出这枚假金币,但身边只有1个没有刻度的天秤.小明先是将金币分成50枚一堆,共两堆称重,在轻的那一堆中又分成两堆,接着在轻的25枚中分成12,12,1三堆称重,若两堆12枚的重量相同,则假币为单独剩下的那一枚,否则在轻的那一堆中继续按照之前的办法称下去,直到找到假金币.请问小明采用的办法与哪个算法有着相似之处?",递归,分治,枚举,贪心,B,"分治算法就是对一个问题采取各个击破的方法,将一个规模为 N的问题分解为K个规模较小的子问题,这些子问题相互独立且与原问题性质相同.只要求出子问题的解,就可得到原问题的解.","35,",3,0,0,分治算法,0,0
3617,0,1,"运行以下代码,正确的打印结果是? def f(s): t=0 max=0 for i in s: if i>=""0"" and i<=""9"": t=t+1 else: if t>max: max=t t=0 print(max) list=""123ab45cd6d"" f(list)",0,1,2,3,D,"本段代码中,函数 f()的作用是求最长的连续数字字符串的长度.","35,",4,0,0,函数使用,0,0
3618,0,1,下列关于函数的描述正确的是?,"函数是可重复使用的,用来实现单一,或相关联功能的代码段",函数中必须 return语句,"函数好处是模块性,但不能提高代码的利用率","函数内容以冒号起始,可以不缩进",A,,"35,",3,0,0,函数的相关概念,0,0
3619,2,1,"调用以下函数时,语句 ""s=s+i""被执行的次数是? def f(): s=0 i=1 while i<10: if i%3==0 or s%2==1: s=s+i i=i+1 print(s)",3,4,5,6,C,,"35,",4,0,0,函数使用,0,0
3620,0,1,"已知有 n本按照书名拼音排序好的图书,使用对分查找法搜索其中任何一本书,最多查找次数为6次,则n的值可能为?",20,50,80,100,B,"对规模为 n的数据进行对分查找时,无论是否查找到,至多进行 |log 2 n|+1次(|log 2 n|表示小于等于log 2 n的最大整数),因此2 5 ≤n＜2 6 ,即 32≤n＜64.","35,",5,0,0,分治算法,0,0
3621,0,1,"某程序代码设计如下,若输入整数 5,则最终输出的结果为? def fact(x): if x==1: s=1 else: s=fact(x-1)*x return s n=int(input(""请输入一个大于1的整数:"")) print(fact(n)+fact(n-1))",120,24120,144,12024,C,"由于 fact(5)=fact(4)*5, fact(4)=fact(3)*4, fact(3)=fact(2)*3, fact(2)=fact(1)*2, fact(1)=1,所以fact(5)+fact(4)=120+24=144.","35,",4,0,0,递归与递推,0,0
3622,0,1,"用匿名函数方式求两个数中较大的数,下列定义语句格式正确的是?","result = lambda 'x,y': y if x> y else x","result= lambda x,y: y if x> y else x","result= lambda 'x,y': x if x> y else y","result= lambda x,y: x if x> y else y",D,"匿名函数的定义语法: lambda 参数:表达式语法.先写lambda关键字,然后依次写匿名函数的参数,多个参数中间用逗号连接,然后是一个冒号,冒号后面写返回的表达式.","35,",5,0,0,匿名函数,0,0
3623,0,1,"下列程序段的正确运行结果是? def fun(m,n): while m!=n: if m>n: m=m-n else: n=n-m return m print(fun(24,16))",4,8,-8,2,B,"自定义函数 fun(m,n)的作用是求m,n两个整数的最大公约数.","35,",4,0,0,自定义函数的创建与调用,0,0
3624,0,1,"运行下列程序,输出结果正确的是? def fun(x,y=5): return x*y a=fun(10,10) print(a)",100,50,10,运行出错,A,参数的默认值被替换.,"35,",4,0,0,函数使用,0,0
3625,0,1,"如果需要在某函数内部调用上一层的局部变量,则可以使用( )关键字",Local,nonlocal,global,nonglobal,B,仅 B可以调用上一层的局部变量,"35,",3,0,0,全局变量和局部变量,0,0
3626,0,1,"在 Python程序中,设已定义函数op,它有一个整型传值参数,一个字符串型传值参数.设x,y为整型变量,z为字符串型变量,则下列能调用该函数的正确语句是?",op,"op(x,y,z)","op x,y","op(x+y,z)",D,"在调用自定函数时需要用到 ""函数名<参数表>""的方法,且自定义函数op共有两个参数.","35,",4,0,0,函数的相关概念,0,0
3627,0,1,下列哪个语句段的时间复杂度最低?,if n%2==0: x=x*2 else: x=x+2,n=1 while n<=100: x=x+2,for i in range(100): for j in range(10): x=x+2,for i in range(100): for j in range(i): x=x+2,A,"时间复杂度按数量级递增顺序为:常数阶,对数阶,线性阶,线性对数阶,平方阶","35,",5,0,0,时间复杂度与空间复杂度,0,0
3628,0,1,下列哪个不是 Python中的内建函数?,asc(x),ord(x),chr(x),abs(x),A,"Python中没有asc(x)这个内建函数,ord(x)函数的作用是返回x对应的ASCII值,chr(x)函数的作用是返回x对应的字符,abs(x)函数的作用是返回x的绝对值.","35,",4,0,0,函数的相关概念,0,0
3629,0,1,"关于函数的定义语句,以下几项中正确的是?","def f(c=2,a,b):","def f(a,b=2,c):","def f(*c,**d,a,b):","def f(a,b,*c,**d):",D,"顺序实参必须要放在关键字实参之前,位置参数 *args必须要在关键字参数**kwargs前,否则会程序报错.","35,",4,0,0,函数的相关概念,0,0
3630,0,1,下列关于递归的描述不正确的是?,递归函数一定包含条件控制语句,递归函数一定包含调用自身的语句,在调用自身函数时需要明确的边界终止条件,"递归算法一般代码简洁,执行效率高,空间复杂度低",D,"递归算法一般代码简洁,易于理解,但执行效率较低,空间复杂度高.","35,",3,0,0,递归与递推,0,0
3631,0,1,下列哪个不是 Python第三方库的pip安装方法?,使用 pip命令,使用 wheel命令,集成安装方法,文件安装方法,B,第三方库安装,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
3632,0,1,"对于下列递归式子,当 n=4时,F的值是? F(n)=F(n-1)+3    F(1)=2",2,5,11,14,C,用递归式子推导得出.,"35,",4,0,0,递归与递推,0,0
3633,0,3,"def add(a, b, c=0): return a+b+c print(add(1, 2, 4)) 这段程序的运行结果为 3.",,,,,0,"在调用函数时给函数提供了实参时, Python将使用指定的实参值","35,",4,0,0,函数的相关概念,0,0
3634,0,3,"算法复杂度分析的目的是分析算法的效率,以求改进.",,,,,1,,"35,",4,0,0,时间复杂度与空间复杂度,0,0
3635,0,3,"sum=0 for i in range(5): sum=sum+i print(sum) 运行以上程序,输出结果是 15.",,,,,0,,"35,",4,0,0,函数使用,0,0
3636,0,3,"已有函数 def demo(*p):return sum(p),表达式 demo(1, 2, 3, 4) 的值为10.",,,,,1,,"35,",4,0,0,函数的相关概念,0,0
3637,0,3,使用 python -m pip install --upgrade pip命令能够升级pip.,,,,,1,,"35,",4,0,0,"第三方库(模块)的获取,安装与调用",0,0
3638,0,3,"在 python函数中,局部变量不能与全局变量重名.",,,,,0,"当全局变量和局部变量同名时,首先会找程序内部有没有局部变量,如果有,则调用,如果没有,才会去调用全局变量","35,",4,0,0,全局变量和局部变量,0,0
3639,0,3,"下列程序段返回的值为 ""Hello!Python"". lst=""Hello!Python"" def f(): global lst lst=""Hello!"" return lst f() print(lst)",,,,,0,"lst=""Hello!Python""  #定义全局变量 def f(): global lst     #global关键字的作用是通过局部变量修改全局变量 lst=""Hello!"" return lst f() print(lst)   #打印全局变量中lst的值","35,",4,0,0,"函数使用,全局变量和局部变量",0,0
3640,0,3,"使用分治算法求解,子问题不能重复",,,,,1,分治算法的子问题之间不可以包含公共的子问题,"35,",3,0,0,分治算法,0,0
3641,0,3,"设计一个程序来求 x n ( x的几次方)的值,算法思想是:把x n 转换为 x*x n-1 ,而 x n-1 又可以转换为 x*x n-2 ,如此重复下去,直到 x*x 0 ,而 x 0 =1,从而求出了x n 的值.这个程序可以用递归来实现.",,,,,1,"递归体现了 ""大事化小,小事化了""的思想,把大问题转换成小问题来解决,且有终止条件,即算法中的到x 0 =1为止.","35,",3,0,0,递归与递推,0,0
3642,0,3,"下列程序段能正确打印 1. def f(a,b): a=a+b b=a-b a=a-b return b print(F(1,4))",,,,,0,"Python中字母区分大小写,所以自定义函数创建和调用时,函数名要一致,否则调用不成功.","35,",4,0,0,自定义函数的创建与调用,0,0
3643,0,4,"利用分治思想,给定一个顺序表,编写一个求出其最大值的程序. 根据上述算法思想,补全下列代码. 输入输出示例:当顺序表是 [22,13,34,4,68,15,5,58,36] ,输出: 68 def fun_max(num=list): return max(num) def fun(num): n = ① if n <= 2: return ② l_list, r_list = num[:n//2], num[n//2:] l_max, r_max = ③ return fun_max( ④ ) if __name__ == ""__main__"": alist = [22,13,34,4,68,15,5,58,36] print(fun(alist))",,,,,"<p class=""MsoNormal""><b><span class=""15""><font face=""宋体"">参考程序:</font></span></b><span><o:p></o:p></span></p><p class=""MsoNormal""><span>def fun_max(num=list):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;return max(num)</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>def fun(num):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;n = len(num)</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;if n &lt;= 2:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return fun_max(num)</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;l_list, r_list = num[:n//2], num[n//2:]</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;l_max, r_max = fun(l_list), fun(r_list)</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;return fun_max([l_max, r_max])</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>if __name__ == ""__main__"":</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;alist = [22,13,34,4,68,15,5,58,36]</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;print(fun(alist))</span><span><o:p></o:p></span></p>","评分标准: ① len(num) 或等效答案; ( 2 分) ② fun_max(num) 或等效答案; ( 2 分) ③ fun(l_list), fun(r_list) 或等效答案; ( 2 分) ④ [l_max, r_max] 或等效答案;( 2 分)","35,",,0,0,,0,0
3644,0,4,"现有 n 个人依次围成一圈玩游戏,从第 1 个人开始报数,数到第 m 个人出局,然后从出局的下一个人开始报数,数到第 m 个人又出局, ... ,如此反复到只剩下最后一个是胜利者.设 n 个人的编号分别为 1 , 2 , ... , n ,打印出局的顺序. 根据上述算法思想,补全下列代码. 输入输出示例:当 n=10 , m=4 ,输出如下: 出局的人是 : 4 出局的人是 : 8 出局的人是 : 2 出局的人是 : 7 出局的人是 : 3 出局的人是 : 10 出局的人是 : 9 出局的人是 : 1 出局的人是 : 6 最后胜利者是 : 5 def fun(n,k): L = list( ① ) if n == 1: return else: x = 0 for i in ② x = ③ - 1 print(' 出局的人是 :',L[x]) del L[x] if x < 0: x = 0 print(' 最后胜利者是 :', ④ ) fun(10,4)",,,,,"<p class=""p""><b><span class=""15""><font face=""宋体"">参考程序:</font></span></b><span><o:p></o:p></span></p><p class=""MsoNormal""><span>def fun(n,k):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; L = list(range(1,n+1))</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; if n == 1:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; return</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; else:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; x = 0</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; for i in range(n-1):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = (x + k) % len(L) - 1</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('出局的人是:',L[x])</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; del L[x]</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if x &lt; 0:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = 0</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp; &nbsp; &nbsp; &nbsp; print('最后胜利者是:',L[0])</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>fun(10,4)</span><span><o:p></o:p></span></p>","评分标准: ① range(1,n+1) 或等效答案;(3分) ② range(n-1): 或等效答案;(3分) ③ (x + k) % len(L) 或等效答案;(3分) ④ L[0] 或等效答案;(3分)","35,",,0,0,,0,0
3645,0,4,"设计一个算法,将一个正整数分解质因数. 程序分析:对 n 进行分解质因数,应先找到一个最小的质数 k ,然后按下述步骤完成: (1) 如果这个质数恰等于 n ,则说明分解质因数的过程已经结束,输出即可. (2) 如果 n>k ,但 n 能被 k 整除,则应打印出 k 的值,并用 n 除以 k 的商 , 作为新的正整数 n ,重复执行第一步. (3) 如果 n 不能被 k 整除,则用 k+1 作为 k 的值,重复执行第一步. 根据上述算法思想,补全下列代码. 输入输出示例:当 n=105 ,输出: 105= 3*5*7 当 n=60 ,输出: 60= 2*2*3*5 def fun(n): print('%d='%n,end=' ') for i in ① : while n!=i: if n>i and ② : print(i,end='*') ③ else: break else: ④ break if __name__ == ""__main__"": while True: num=input("" 输入一个正整数: "") if not num.isdigit(): break fun(int(num))",,,,,"<p class=""MsoNormal""><b><span class=""15""><font face=""宋体"">参考程序:</font></span></b><span><o:p></o:p></span></p><p class=""MsoNormal""><span>def fun(n):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;print('%d='%n,end=' ')</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2,n+1):</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while n!=i:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if n&gt;i and n%i==0:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(i,end='*')</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n=n//i</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(n)</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>if __name__ == ""__main__"":</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;while True:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num=input(""<font face=""宋体"">输入一个正整数:</font><font face=""Calibri"">"")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not num.isdigit():</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fun(int(num))</span><span><o:p></o:p></span></p>","评分标准: ① range(2,n+1) 或等效答案;( 3 分) ② n%i==0 或等效答案;( 3 分) ③ n=n//i 或等效答案;( 2 分) ④ print(n) 或等效答案;( 2 分)","35,",,0,0,,0,0
