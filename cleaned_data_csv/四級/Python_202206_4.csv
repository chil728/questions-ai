id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,examDots,difficultyLevel,weType,isMySubject,knowledgeNames,answerStatus,compileEnvironment
7074,0,1,"有如下Python程序,包含lambda函数,运行该程序后,输出的结果是?( )g = lambda x,y:x*yprint(g(2,3))",2,3,6,8,C,"g = lambda x,y:x*y,lambda函数返回参数x和y的积,因此选C.","35,",5,0,0,匿名函数,0,0
7075,0,1,"运行下列程序,输出的结果是?( ) def dtox(x,base = 2): s = [] while x>0: s.append(x % base) x = x // base return s print(dtox(11))",程序出错,1101,"[1, 1, 0, 1]","[1, 0, 1, 1]",C,"函数dtox有一个位置参数x,一个默认值参数base,默认值是2,本函数的功能是将参数x转换成base进制,保存列表s返回.本程序将参数11转换成二进制后的结果,因此选C.","35,",5,0,0,函数使用,0,0
7076,0,1,下列哪项不是函数的优点?( ),提高代码的复用率.,"使得程序简洁,程序功能清晰.","便于程序的修改,便于扩展.",代码运行速度更快.,D,"函数的使用不一定使得代码运行速度更快,其它3项是函数的优点.","35,",3,0,0,函数的相关概念,0,0
7077,0,1,下列关于函数的描述正确的是?( ),函数内的语句不会改变任何非全局变量的值.,传入函数的参数都会以副本的形式存在函数中.,函数的名称不能与Python的保留字相同.,每个函数必须有一个return语句.,C,"函数的名称不能与Python的保留字相同,其他均错误.","35,",3,0,0,函数的相关概念,0,0
7078,0,1,Python中自定义函数的关键字是?( ),sub,def,function,void,B,"Python中自定义函数使用def关键字,因此选B.","35,",3,0,0,自定义函数的创建与调用,0,0
7109,0,1,"运行下列程序,输出的结果是?( ) def nxs(x): s = 0 while x: s = s * 10 + x % 10 x //= 10 return s print(nxs(106))",106,610,160,601,D,"自定义函数nxs功能将参数x各位数字逆序拼接成新的整数,即将106,拼接成(6*10+0)*10+1,即601,选D.","35,",4,0,0,函数使用,0,0
7110,0,1,"Python编写的自定义函数dy,执行该程序段后,输出的结果是?( ) def dy(x,y): return x>y print(dy(10,20))",10,20,False,True,C,"自定义函数dy功能是判断x与y的大小,并返回对应的逻辑值,本题中x=10,y=20;因此函数的返回值是False.选C.","35,",4,0,0,函数使用,0,0
7111,0,1,"在函数中有一种叫空函数. 构造一个空函数,下面的横线处应填?( ) def  函数名( ): ______________",None,return None,pass,empty,C,"pass 是一种空操作,解释器执行到它的时候,除了检查语法是否合法,什么也不做就直接跳过.","35,",4,0,0,算法优化,0,0
7112,0,1,"下列代码的输出结果是?( ) def fun(a,b): t = a a = b b = t print(a, b) fun(pow(3,2),pow(2,3))   #pow(x,y)返回x**y的值",3 2,8 9,2 3,9 8,B,"该函数作用,交换两个参数位置,再输出.","35,",4,0,0,函数使用,0,0
7113,0,1,"函数中用return [表达式] 结束函数,选择性地返回一个值给调用方,有时不带表达式的return相当于返回?( )",0,None,1,False,B,"不带表达式的return,相当于返回None.","35,",4,0,0,函数的返回值,0,0
7114,0,1,"对于下面的函数: def f(x,z,y=2): print(x+y+z) 用f(1,2,3)和f(1,2)两个调用语句,运行结果分别是?( )",都是5,6和5,都是6,5和6,B,Python函数中位置参数和关键字参数.,"35,",4,0,0,函数的相关概念,0,0
7115,0,1,"下列这段程序的打印结果是?( ) def demo(item,lis=[]): lis=[] lis.append(item) return lis print(demo('a'),end='') print(demo('b'))","['a']['a', 'b']",['a']['b'],[][],[ ]['b'],B,函数调用.,"35,",4,0,0,函数使用,0,0
7116,0,1,函数如下: def showNumber(numbers): for n in numbers: print(n) 下面哪个选项在调用该函数时会报错?( ),"showNumber([2,4,5])",showNumber('abcesf'),showNumber(3.4),"showNumber((12,4,5))",C,"3.4是浮点数,不是序列对象.","35,",4,0,0,函数使用,0,0
7117,0,1,"下列关键字中,用来导入第三方库的是?( )",include,from,import,continue,C,import用来导入第三方库.,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
7118,0,1,"以下选项中,不属于第三方库安装工具pip能够实现的功能是?( )",安装一个第三方库.,卸载已经安装的第三方库.,修改已经安装的第三方库.,查询已经安装的第三方库.,C,"pip可以安装,卸载,查询第三方库.","35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
7119,0,1,"关于评价算法的优劣,以下说法正确的是?( )",只要考虑是否得出正确答案.,只要考虑算法的执行时间.,只要考虑算法所占用的空间.,从算法执行时间和需占用的空间两方面考虑.,D,评价算法的指标主要有时间复杂度和空间复杂度.,"35,",4,0,0,时间复杂度与空间复杂度,0,0
7120,0,1,下列程序实现求菲波那契数列第4项的值: def f(n): if n==1 or n==2: return 1 elif n>2: return f(n-1)+f(n-2) else: return -1 print(f(4)) 请问:这种解决方法属于哪种算法?( ),归纳,列举,递推,递归,D,显然是典型的递归算法.,"35,",3,0,0,递归与递推,0,0
7121,0,1,"著名的菲波那契数列为1,1,2,3,5,8,.......即除开始的两项为1外,其余每一项均为前两项之和. 下面的程序实现计算该数列的第4项值的大小. n,a,b=4,1,1 if n==1: print(""第%d个数为%d.""%_____(1)______) if n==2: print(""第%d个数为%d.""%(n,b)) if n>2: for i in range(2,n): result=a+b a,b=b,result print(""第%d个数为%d.""%(n,result)) 请问:横线(1)所在位置不适合填入以下哪个选项?( )","(n,1)","(n,a)","(n,b)","(a,n)",D,"当n=1时,a,b都是1,因此,此时使用(n,1),(n,a),(n,b)这几项都是一样的.","35,",4,0,0,函数使用,0,0
7122,0,1,if n==1: return 1 else: return f(n-1)+(n-1)*f(n-1),64,24,4,16,B,f(4) =f(3)+3f(3) =4(f(3)) =4(f(2)+2f(2)) =12(f(2)) =12(f(1)+f(1)) =12*2 =24,"35,",4,0,0,"函数使用,递归与递推",0,0
7123,1,1,已知Pell数列定义如下: 第5项的值是?( ),29,30,12,32,A,"数列为1,2,5,12,29,......","35,",4,0,0,函数使用,0,0
7124,0,1,"运行下列程序,输出的结果是?( ) def Pell(n): if n==1: return 1 if n==2: return 2 if n>=3: return 2*Pell(n-1)+Pell(n-2) print(Pell(4))",12,4,3,24,A,按照程序逻辑为12.,"35,",4,0,0,函数使用,0,0
7125,0,1,"运行下列程序,输出的结果是?( ) def f(n): if n==1 or n==2: return 1 elif n>2: return f(n-1)+f(n-2) else: return -1 print(f(-2))",-2,-1,出错,1,B,根据程序逻辑返回-1.,"35,",4,0,0,函数使用,0,0
7126,0,1,"在1-20之间玩猜数字的游戏时,如果采用二分法的策略,并且给'大了'或'小了'的提示,最差的情况下多少次就可以猜中?( )",5,10,15,20,A,最多5次就可以确定一个整数.,"35,",5,0,0,分治算法,0,0
7127,0,1,"下列选项中,哪一项不是分治算法的特征?( )",问题的规模缩小到一定程度就可以容易解决.,该问题分解出的子问题的解可以合并为该问题的解.,各个子问题必须分解到不能分解为止.,该问题具有最优子结构性质.,C,"子问题分解到什么程度需要视具体问题而定,并不一定要分解到不能分解为止.其余三个选项都是分治算法的特征.","35,",4,0,0,分治算法,0,0
7128,0,1,下列排序算法中利用了分治算法思想的是?( ),冒泡排序,插入排序,选择排序,快速排序,D,快速排序利用了分治算法思想.,"35,",4,0,0,分治算法,0,0
7129,0,3,Python中自定义函数的代码需要写在调用该函数之前.( ),,,,,1,Python中自定义函数的代码需要写在调用该函数之前.,"35,",4,0,0,自定义函数的创建与调用,0,0
7130,0,3,"Python定义函数时,可选参数必须写在非可选参数后面.( )",,,,,1,"Python定义函数时,可选参数必须写在非可选参数后面.","35,",4,0,0,函数的相关概念,0,0
7131,0,3,"Python中编写函数时,必须指明该函数的返回值.( )",,,,,0,"Python中编写函数时,不一定需要指明该函数的返回值.","35,",4,0,0,函数的相关概念,0,0
7132,0,3,"用户自定义函数是用户自己写的一段程序,一般包括函数名,参数,返回值,函数体等四部分.其中,函数名和参数是必不可少的部分.( )",,,,,0,,"35,",4,0,0,自定义函数的创建与调用,0,0
7133,0,3,"自定义函数def块中的代码不是主程序的一部分,运行会跳过该段代码.( )",,,,,1,"def块中的代码并不是主程序的一部分,程序运行时会跳过这一部分,从def块以外的第一行代码开始运行.","35,",3,0,0,自定义函数的创建与调用,0,0
7134,0,3,"算法优化主要是为了减少冗余数据,优化时间复杂度和空间复杂度.( )",,,,,1,算法优化包括时间和空间两个方面的优化.,"35,",4,0,0,算法优化,0,0
7135,0,3,在Python中使用爬虫技术抓取网站信息需要用到第三方库.( ),,,,,1,Python的基本库不支持网络爬虫.,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
7136,0,3,"对于递归而言,递推与回归,二者缺一不可.( )",,,,,1,递推关系是递归的重要组成.,"35,",3,0,0,递归与递推,0,0
7137,0,3,"递归算法跟递推算法是一样的,都在重复调用.( )",,,,,0,二者不同.,"35,",3,0,0,递归与递推,0,0
7138,0,3,"使用分治算法解决问题的一般步骤是分解,求解,合并.( )",,,,,1,参见分治算法的定义.,"35,",3,0,0,分治算法,0,0
7139,0,4,"字符加密.将大写字母逐个按其ASCII值转换为7位二进制数,并在最左边补0,使得每个字母转换为8位二进制数,然后将8位二进制数每四位转为十六进制数.如明文是""CIE"",加密后的密文是""434945"".编写的python程序如下,完善划线处的代码. def xtob(n): #将整数转为二进制数 if n <= 1: return str(n) return  xtob(n//2)+ ① mingwen = ""CIE"" he = '0123456789ABCDEF' rst = '' for c in mingwen: s = ""0"" + xtob(ord(c)) #将明文转为8位二进制数 i = 0 data = 0 while i < 8: data =data * 2 + ② if (i + 1) % 4 == 0: rst = rst + he[data] data = 0 ③ print('密文是:',rst)",,,,,"<p><span><strong>参考程序:</strong></span></p><p>def xtob(n): #将整数转为二进制数<br>&nbsp; &nbsp; if n &lt;= 1:<br>&nbsp; &nbsp; &nbsp; &nbsp; return str(n)<br>&nbsp; &nbsp; return xtob(n//2)+<strong><span>str(n%2)&nbsp;</span></strong><br>mingwen = ""CIE""&nbsp;<br>he = '0123456789ABCDEF'&nbsp;<br>rst = ''&nbsp;<br>for c in mingwen:<br>&nbsp; &nbsp; s = ""0"" + xtob(ord(c)) #将明文转为8位二进制数<br>&nbsp; &nbsp; i = 0<br>&nbsp; &nbsp; data = 0<br>&nbsp; &nbsp; while i &lt; 8:<br>&nbsp; &nbsp; &nbsp; &nbsp; data = data * 2 +&nbsp;<strong><span>int(s[i])</span></strong><br>&nbsp; &nbsp; &nbsp; &nbsp; if (i + 1) % 4 == 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rst = rst + he[data]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = 0<br>&nbsp; &nbsp; &nbsp;&nbsp;<strong><span>&nbsp; i += 1&nbsp;</span></strong><br>print('密文是:',rst)</p><p><strong>说明:</strong><span>本题将每个大写字母转换为二进制数,①处代码是递归的方法将十进制转二进制,若整数不是0或1的时候,继续整除2,因此①处代码是xtob(n//2)+str(n%2);8位二进制数每4位二进制数转十六进制数,因此②处的代码是data * 2 + int(s[i]) ;③处的代码是循环变量i自增1,因此该处代码是i=i+1.</span></p>",评分标准: (1) str(n%2) ; (4分) (2) int(s[i]) ; (4分) (3)i += 1 或i=i+1. (4分),"35,",,0,0,,0,0
7140,0,4,"辗转相除法求最大公约数, 下列函数是用递归算法实现的, 请完善横线处的代码. def gcd(a,b): m=a%b if m==0: return ① else: a=b ② return ③ print(gcd(12,18))",,,,,"<p><span><strong>参考程序:</strong></span></p><p>def gcd(a,b):</p><p><span>&nbsp; &nbsp; m=a%b</span><br><span>&nbsp; &nbsp; if m==0:</span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;</span><strong><span>b</span></strong><br><span>&nbsp; &nbsp; else:</span><br><span>&nbsp; &nbsp; &nbsp; &nbsp; a=b</span><br><span>&nbsp; &nbsp; &nbsp; &nbsp;</span><span><strong>&nbsp;b=m</strong></span><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;&nbsp;<span><strong>gcd(a,b)</strong></span></p><p>print(gcd(12,18))</p>","评分标准: (1) b; (3分) (2) b=m;(3分) (3) gcd(a,b).(4分)","35,",,0,0,,0,0
7141,0,4,"下面的程序运用分治算法寻找列表中的最大值.请将空格补全代码. #子问题规模小于或等于2时 def zui_da_zhi(a_list): if ① : if a_list[0]>=a_list[1]: most=a_list[0] else: most=a_list[1] else: most=a_list[0] return most # 分治算法排序 def fen_zhi(init_list): n=len(init_list) if n<=2:                  #若问题规模小于或等于2,解决 return zui_da_zhi(init_list) #分解(子问题规模为n/2) left_list,right_list= ② #递归,分治 left_max,right_max= ③ #合并 return zui_da_zhi([left_max,right_max]) #测试数据 test_data=[12,25,4,47,69,5,4,6,37,89,21] print('最大值为:',fen_zhi(test_data))",,,,,"<p><span><strong>参考程序:</strong></span></p><p>#子问题规模小于或等于2时<br>def zui_da_zhi(a_list):<br>&nbsp; &nbsp; if&nbsp;<strong><span>len(a_list) == 2</span></strong>:<br>&nbsp; &nbsp; &nbsp; &nbsp; if a_list[0]&gt;=a_list[1]:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; most=a_list[0]<br>&nbsp; &nbsp; &nbsp; &nbsp; else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; most=a_list[1]<br>&nbsp; &nbsp; else:<br>&nbsp; &nbsp; &nbsp; &nbsp; most=a_list[0]<br>&nbsp; &nbsp; return most<br># 分治算法排序<br>def fen_zhi(init_list):<br>&nbsp; &nbsp; n=len(init_list)<br>&nbsp; &nbsp; if n&lt;=2:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #若问题规模小于或等于2,解决<br>&nbsp; &nbsp; &nbsp; &nbsp; return zui_da_zhi(init_list)<br>&nbsp; &nbsp; #分解(子问题规模为n/2)<br>&nbsp; &nbsp; left_list,right_list=<span><span><strong>init_list</strong></span><span><strong>[</strong></span><strong>:n/</strong><strong>/2],init_list[n//2:]</strong></span><br>&nbsp; &nbsp; #递归,分治<br>&nbsp; &nbsp; left_max,right_max=<strong><span>fen_zhi(left_list),fen_zhi(right_list)</span></strong><br>&nbsp; &nbsp; #合并<br>&nbsp; &nbsp; return zui_da_zhi([left_max,right_max])<br><br>#测试数据<br>test_data=[12,25,4,47,69,5,4,6,37,89,21]<br>print('最大值为:',fen_zhi(test_data))</p>","评分标准: (1) len(a_list) == 2;  (2分) (2) init_list[:n//2],init_list[n//2:] ; (3分) (3) fen_zhi(left_list),fen_zhi(right_list) . (3分)","35,",,0,0,,0,0
