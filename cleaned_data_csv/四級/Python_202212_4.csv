id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,examDots,difficultyLevel,weType,isMySubject,knowledgeNames,answerStatus,compileEnvironment
11367,3,1,"有 n 个按名称排序的商品,使用对分查找法搜索任何一商品,最多查找次数为 5 次,则 n 的值可能为?( )",5,15,30,35,C,"对分查找最多查找次数 m 与个数之间 n 的关系是: n 对 2 的对数的取整后加 1 ,现在最多查找次数是 5 次,因此 n 的取值范围在 [2^4+1,2^5] 即 [16,31] 之间,因此选 C .","35,",5,0,0,分治算法,0,0
11368,3,1,下列有关分治算法思想的描述不正确的是?( ),将问题分解成的子问题具有相同的模式,"当问题足够小时,可以直接求解",可以将子问题的结果合并成原问题的解,"将问题分解出的各个子问题相互包含,相互之间可以有公共子问题",D,"将问题分解出的各个子问题是相互独立的,即子问题之间不包含公共子子问题","35,",4,0,0,分治算法,0,0
11369,3,1,下列问题使用分治算法思想的是?( ),求 100 以内的素数,求 100 个整数之和,求斐波那契数列第 n 项,快速排序算法对 n 个数排序,D,快速排序算法使用了分治算法.因此选 D .,"35,",4,0,0,分治算法,0,0
11370,3,1,"李宇同学利用 Python 语言编写了一段""根据出生年月判断生肖属相""的程序,调试运行时,程序没有报错且顺利运行,但未能正确输出对应属相,造成这个结果的原因可能是?( )",程序语句语法错误,时间复杂度太高,求解算法逻辑错误,Python 环境配置不对,C,"程序能正常运行,排除了其他三个可能.","35,",4,0,0,函数使用,0,0
11371,3,1,"一般来说,递归需要有边界条件,递归前进段和递归返回段.当不满足边界条件时,( );当满足边界条件时,( ).","返回,前进","中断,前进","前进,返回","中断,返回",C,"递归运行的条件,不满足边界条件前进,满足返回.","35,",4,0,0,递归与递推,0,0
11372,3,1,以下哪一项不是递归算法的特征?( ),"要实现递归必须有一个函数,并且在这个函数体内要自己调用自己.","递归必须要有判断条件 , 这个判断条件可以是判断次数.","到达判断的条件后必须有返回,目的是结束递归.","未到达判断条件时,不可以返回该函数.",D,"未到达判断条件时,可以返回该函数,也可以不返回.","35,",4,0,0,递归与递推,0,0
11373,3,1,"关于斐波那契数列,下列空白处的代码填写正确的是?( ) def func(num): if num==1: return 1 elif num==2: return 1 else: lst=[] b=input(' 请输入选择的数字: ') b1=int(b) for a in range(1,b1+1): print(func(a)) lst.append(func(a)) a+=1 print(lst)",return func(num+1)+func(num-2),return func(num-1)+func(num),return func(num-1)+func(num-2),return func(num-1)+func(num+2),C,"斐波那契数列,从第三项开始 , 每一项都等于前两项之和.","35,",4,0,0,递归与递推,0,0
11374,3,1,"在有序列表[2,3,10,15,20,25,28,29,30,35,40]中,使用二分法查找20,需要查找多少次能找到?( )",5,4,3,2,B,可以模拟二分法的执行过程分析得出.,"35,",5,0,0,分治算法,0,0
11375,3,1,下列程序输出正确的是?( ) def ac(n): if n < 0: return else: ac(n-1) print(n) ac(4),"0,1,2,3,4","1,2,3,4",0 1 2 3 4,1 2 3 4,C,"依次输出 0-4 , print() 默认换行.","35,",3,0,0,算法优化,0,0
11376,3,1,"阅读下列程序,运行结果正确的是?( ) def power(x,y): if y==0: return 1 else: return x * power(x,y-1) print(power(4,5))",243,81,1206,1024,D,"power(a,b) 表示 a 的 b 次幂,当 y 不等于 0 ,返回 x*power(x,y-1) .据题, x=4 , y=5, 因此 4*power(4,4) ,即 4* ( 4 的 4 次幂),结果为 1024 .","35,",5,0,0,函数使用,0,0
11377,3,1,下载但不安装一个第三方库的命令格式是?( ),pip search 第三方库名,pip uninstall 第三方库名,pip install 第三方库名,pip download 第三方库名,D,pip search 为搜索三方包 pip install 为安装三方包 pip uninstall 为卸载三方包,"35,",4,0,0,"第三方库(模块)的获取,安装与调用",0,0
11378,3,1,不需要使用 Python 的 pip 工具安装的是?( ),Python 标准库,第三方库,用户自己开发的库,Python 扩展库,A,其它要安装,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
11379,3,1,"使用 lambda 定义匿名函数如下: f=lambda x:x+1 ,则 f(f(1)) 代码运行结果是?( )",1,2,3,会报错,C,"f(1)=2 , f(2)=3","35,",4,0,0,匿名函数,0,0
11380,3,1,"关于函数,以下选项中描述错误的是?( )","函数是一段具有特定功能的,可重用的语句组.","函数能完成特定的功能,对函数的调用不需要了解函数内部实现原理,只要了解函数的输入输出方式即可.",使用函数的主要目的是减低编程难度和代码重用.,"Python 使用"" del ""保留字定义一个函数.",D,"Python 使用"" def ""保留字定义一个函数.","35,",3,0,0,函数的相关概念,0,0
11381,3,1,"某自定义函数有两个参数,并且这两个参数都指定了默认值.我们在调用这个函数时,最少需要提供几个实参?( )",0,1,2,3,A,只要有默认值就可以省略.,"35,",4,0,0,自定义函数的创建与调用,0,0
11382,3,1,"以下关于 Python 中使用函数的描述,错误的是?( )",程序里一定要有 main 函数.,使用函数前要先定义函数.,函数在被调用时才执行.,"函数执行结束后,程序执行流程会自动返回到函数被调用的语句之后.",A,Python 程序不必一定要有 main 函数.,"35,",3,0,0,函数的相关概念,0,0
11383,3,1,"在 Python 中,函数通过可变参数 *args 传入的参数,在函数内以哪种数据类型存储?( )",元组,列表,集合,字典,A,可变参数在函数内以元组方式存储.,"35,",4,0,0,函数的相关概念,0,0
11384,3,1,下列关于函数调用的说法正确的是?( ),调用函数时一定要赋值.,"只要安装成功第三方库,不要导入,就可以直接调用第三方库里的函数.",Python 内置的标准函数可以多次调用.,"函数调用时,如果参数有默认值,就不能给它再赋新的值了.",C,"调用函数时不一定是必须要给参数赋值的;先导入第三方库,再调用第三方库里的函数;有默认值的参数也可以赋新值.","35,",4,0,0,自定义函数的创建与调用,0,0
11385,3,1,自定义函数的关键字是?( ),define,del,def,dfe,C,自定义函数的关键字是 def .,"35,",3,0,0,自定义函数的创建与调用,0,0
11386,3,1,下列选项中不能作为自定义函数名的是?( ),Int,_int2,str2int,2_int,D,函数名不能以数字开头.,"35,",3,0,0,自定义函数的创建与调用,0,0
11387,3,1,"函数定义如下: def func(a,b=0,c=0): pass 下列选项调用错误的是?( )",func(1),func(1),"func(1, ,3)","func(1,2,3)",C,"C 选项中连续输入了两个逗号,解释器会报语法错误.","35,",3,0,0,函数使用,0,0
11388,3,1,"下列选项中,函数定义错误的是?( )","def afunc(a,b=2):","def bfunc(a,b):","def cfunc(a,*b):","def dfunc(*a,b):",D,可变参数必须在不可变参数的后面.,"35,",3,0,0,自定义函数的创建与调用,0,0
11389,3,1,"运行下列代码,输出结果为?( ) def func(a,b,*args): print(a) print(b) print(args) func(1,2,3,4,5,6)","1,2,3,4,5,6","1 2 (3,4,5,6)","1 2 [3,4,5,6]","1 2 3,4,5,6",B,"a,b 是位置参数,所以 a=1,b=2, 其余的参数会被 *args 收集打包放进一个元组中,即( 3 , 4 , 5 , 6 ).","35,",4,0,0,函数的相关概念,0,0
11390,3,1,下列关于函数的说法正确的是?( ),一个函数在同一个程序中最多只能被调用 999 次,一个函数在同一个程序中最多只能被调用 999 次,"使用 Python 内置模块里的函数时,要先导入该模块到当前文件中",用没有参数的函数时可以不带圆括号,C,"函数的调用次数没有限制, A 错误;函数的返回值可以赋值给变量, B 错误;调用没有参数的函数时,函数名后面也要跟一对圆括号, D 错误.","35,",3,0,0,"函数的相关概念,自定义函数的创建与调用",0,0
11391,3,1,"下列选项中,不是函数的是?( )",max(),input(),string(),sum(),C,Python 中 string 为模块,"35,",3,0,0,函数的相关概念,0,0
11392,3,3,计算下面这段程序的时间复杂度为平方阶: O ( n^2 ).( ) sum1=0 for i in range(101): sum1+=i,,,,,0,"时间复杂度为线性阶,计 O ( n ).","35,",5,0,0,时间复杂度与空间复杂度,0,0
11393,3,3,汉诺塔游戏是递归调用的经典案例.( ),,,,,1,汉诺塔是学习递归算法最为常见的例子.,"35,",4,0,0,递归与递推,0,0
11394,3,3,递推关系是递归的重要组成.( ),,,,,1,递推关系是递归的重要组成.( ),"35,",4,0,0,递归与递推,0,0
11395,3,3,"以下命令: pip get pandas 用于下载第三方库 pandas ,但不马上安装.( )",,,,,0,没有 get 这个命令.,"35,",4,0,0,"第三方库(模块)的获取,安装与调用",0,0
11396,3,3,"使用 Python 语言编程,可以定义一个名叫 pass 的函数.( )",,,,,0,pass 是保留字.,"35,",3,0,0,函数的相关概念,0,0
11397,3,3,"函数中没有 return 语句或者 return 语句不带任何返回值,那么该函数的返回值为 True .",,,,,0,返回值为 None,"35,",3,0,0,函数的返回值,0,0
11398,3,3,"在 Python 中调用函数的时候,必须将每个实参都关联到函数定义中的每一个形参,最简单的关联方式就是基于实参的顺序.但也可以通过关键字实参的""关键字 - 值""方式关联形参,这时就不必考虑函数调用过程中实参的顺序.( )",,,,,1,,"35,",4,0,0,形参和实参,0,0
11399,3,3,"在 Python 中,全局变量名和局部变量名一定不能重名.( )",,,,,0,全局变量名和局部变量名可以是相同的变量名.,"35,",4,0,0,全局变量和局部变量,0,0
11400,3,3,"调用函数时, Python 将形式参数传递给实际参数.( )",,,,,0,"调用函数时, Python 将实际参数传递给形式参数.","35,",4,0,0,形参和实参,0,0
11401,3,3,"分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题,这些子问题相互独立且与原问题性质相同.( )",,,,,1,"分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题,这些子问题相互独立且与原问题性质相同.","35,",4,0,0,分治算法,0,0
11402,3,4,"从键盘接收一组不重复整数,并将这组整数按从小到大的顺序排列. 以下程序采取快速排序法对这组整数进行排序. 快速排序法的原理是: ( 1 )取这组数据中间那个数为锚定值 mid ; ( 2 )从这组数据开头往右找,遇到比 mid 大的数则停下,位置记为 i ; ( 3 )从这组数据末尾往左找,遇到比 mid 小的数则停下,位置记为 j ; ( 4 )如果此时 i 仍在 j 左边,即 i<=j ,则交换这两个数; ( 5 )重复( 2 ) ~ ( 4 )直到 i , j 重合; ( 6 )对 i 左边的数进行快速排序; ( 7 )对右边的数进行快速排序. 输入示例: 请输入需要排序的一组整数,数与数之间用空格隔开: 6 10 11 8 4 1 9 7 输出示例: 排序结果: 1 4 6 7 8 9 10 11 程序模板: def QuickSort(left,right): if ① : return mid=Numbers[left+(right-left)//2] i=left j=right while i<j: while Numbers[i]<mid: i+=1 while Numbers[j]>mid: j-=1 if i<=j: ② QuickSort(left,j-1) QuickSort(i+1,right) Numbers=list(map(int,input("" 请输入需要排序的一组整数,数与数之间用空格隔开: ""). ③ )) QuickSort(0, ④ ) print("" 排序结果: "",end="""") for i in Numbers: print(i,end="" "")",,,,,"<p class=""MsoNormal""><span><font face=""Calibri"">def QuickSort(left,right):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; if&nbsp;left&gt;=right:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; return</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; mid=Numbers[left+(right-left)//2]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; i=left</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; j=right</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; while i&lt;j:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; while Numbers[i]&lt;mid:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i+=1</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; while Numbers[j]&gt;mid:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-=1</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; if i&lt;=j:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Numbers[i],Numbers[j]=Numbers[j],Numbers[i]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; QuickSort(left,j-1)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; QuickSort(i+1,right)&nbsp;</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">Numbers=list(map(int,input(""</font><font face=""宋体"">请输入需要排序的一组整数,数与数之间用空格隔开:</font><font face=""Calibri"">"").split()))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">QuickSort(0,len(Numbers)-1)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">print(""</font><font face=""宋体"">排序结果:</font><font face=""Calibri"">"",end="""")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">for i in Numbers:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; print(i,end="" "")</font></span><span><o:p></o:p></span></p>","( 1 ) left>=right ;( 2 分) ( 2 ) Numbers[i],Numbers[j]=Numbers[j],Numbers[i] ;( 2 分) ( 3 ) split() ;( 2 分) ( 4 ) len(Numbers)-1 .( 2 分)","35,",,0,0,,0,0
11403,3,4,"鸡兔同笼是中国古代的数学名题之一.大约在 1500 年前,<孙子算经>中就记载了这个有趣的问题.书中是这样叙述的: 今有雉兔同笼,上有三十五头,下有九十四足,问雉兔各几何? 意思是:有若干只鸡兔同在一个笼子里(笼中最少有一只鸡和一只兔),从上面数,有 35 个头,从下面数,有 94 只脚.问笼中各有多少只鸡和兔? 今天我们用编程的方法来求解一下这道数学命题吧. def ji_tu(head,leg): j=0 t=0 while j<head: j += 1 t = ① if (leg== ② ): print(' 有鸡 {} 只,有兔子 {} 只. '.format( ③ )) return (j,t) while True: try: sum_head=int(input(' 请输入总头数: ')) sum_leg=int(input(' 请输入总脚数: ')) if ④ : print(' 输入鸡和兔子的总头数或总脚数错误,请重新输入! ') else: ji_tu( ⑤ ) except: print(' 能不能正常输入数据? ')",,,,,"<p class=""MsoNormal""><span>参考程序:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">def ji_tu(head,leg):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; j=0</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; t=0</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; while j&lt;head:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; j += 1</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; t =&nbsp;head-j</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; if (leg==(j*2+t*4)):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=""宋体"">有鸡</font><font face=""Calibri"">{}</font><font face=""宋体"">只,有兔子</font><font face=""Calibri"">{}</font><font face=""宋体"">只.</font><font face=""Calibri"">'.format(j,t))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; return (j,t)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">while True:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; try:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; sum_head=int(input('</font><font face=""宋体"">请输入总头数:</font><font face=""Calibri"">'))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; sum_leg=int(input('</font><font face=""宋体"">请输入总脚数:</font><font face=""Calibri"">'))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; if&nbsp;sum_head&lt;2 or sum_leg&lt;6:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=""宋体"">输入鸡和兔子的总头数或总脚数错误,请重新输入!</font><font face=""Calibri"">')</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; else:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ji_tu(sum_head,sum_leg)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; except:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; print('</font><font face=""宋体"">能不能正常输入数据?</font><font face=""Calibri"">')</font></span><span><o:p></o:p></span></p>","( 1 ) head-j ; (2 分 ) ( 2 ) (j*2+t*4) ; (3 分 ) ( 3 ) j,t ; (2 分 ) ( 4 ) sum_head<2 or sum_leg<6 ; (3 分 ) ( 5 ) sum_head,sum_leg . (2 分 )","35,",,0,0,,0,0
11404,3,4,"有一个游戏:有两个人,第一个人先从 1 和 2 中挑一个数字,第二个人可以在对方的基础上选择加 1 或者加 2 ,然后又轮到第一个人,他也可以选择加 1 或者加 2 , 之后再把选择权交给对方,就这样双方交替地选择加 1 或者加 2 ,谁先加到 20 ,谁就赢了.在不考虑谁输谁赢的情况下,从一开始(以 1 或 2 为起点)加到 20 , 有多少种不同的递加过程?比如 1 , 4 , 7 , 10 , 12 , 15 , 18 , 20 算一种; 2 , 5 , 8 , 11 , 14 , 17 , 20 又是一种.那么一共会有多少种这样的过程呢? 我们可以用递归算法来解决这个问题,请补全代码. def guo_cheng(n): if ① : return 1 return ② # 输出所有过程的个数 print (guo_cheng( ③ ))",,,,,"<p class=""MsoNormal""><span>参考程序:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">def guo_cheng(n):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; if&nbsp;n==1 or n==2:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; &nbsp; &nbsp; return 1</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp; &nbsp; return&nbsp;guo_cheng(n-1)+guo_cheng(n-2)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">&nbsp;</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri""># </font><font face=""宋体"">输出所有过程的个数</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">print (guo_cheng(20))</font></span><span><o:p></o:p></span></p>",( 1 ) n==1 or n==2 ; (3 分 ) ( 2 ) guo_cheng(n-1)+guo_cheng(n-2) ; (4 分 ) ( 3 ) 20 . (3 分 ),"35,",,0,0,,0,0
