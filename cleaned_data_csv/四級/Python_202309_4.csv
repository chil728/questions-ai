id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,examDots,difficultyLevel,weType,isMySubject,knowledgeNames,answerStatus,compileEnvironment
10000,4,1,"考察以下函数定义代码: def func(x:int,y:str)->str: z=x*y return z 以下陈述正确的是?( )","Python是一种动态类型语言,不强制要求指定参数类型,上述代码行是不符合Python语法的","为提高程序的可靠性,Python函数定义时允许为形参指定数据类型,也允许为返回值指定类型","由于为函数指定了返回值类型,变量z一定要做类型转换后,才能用于上述return语句中","由于为形参指定了不同的数据类型,变量x和y也需要先做类型转换后才能进行上述运算",B,"Python不强制要求指定参数类型,但是为提高程序的可靠性,Python函数定义时允许为形参指定数据类型,也允许为返回值指定类型.","35,",4,0,0,函数的相关概念,0,0
9976,0,1,"用枚举算法求解""100以内既能被3整除又能被4整除的元素""时,在下列数值范围内,算法执行效率最高的是?( )",1~101,4~100,12~100,12~96,D,"在选取循环控制变量时,枚举范围应尽可能小,但又不能遗漏.","35,",4,0,0,算法优化,0,0
9977,0,1,"下列有关函数的描述中,正确的是?( )",函数中必须有return语句,在函数内部不能使用全局变量,函数能提高应用的模块化程度和代码的重复利用率,"函数内容以大括号起始,并且缩进",C,函数能提高应用的模块化程度和代码的重复利用率,"35,",3,0,0,函数的相关概念,0,0
9978,0,1,下列哪个语句能够定义参数个数不确定的函数?( ),hs(parameters),hs(parameters[]),hs(parameters{}),hs(*parameters),D,"当不确定需要传入的值是多少个时,在定义形参时,可以使用*parameters来表示.","35,",5,0,0,函数的相关概念,0,0
9979,0,1,"执行如下Python代码的结果是?( ) def area(r,pi=3.14): return r*r*pi print(area(2,10))",40,200,400,20,A,"函数运行结果,2*2*10,结果是40.","35,",3,0,0,函数使用,0,0
9980,0,1,"执行如下Python代码,输出结果是?( ) def hs(num): num += 1 return num n=10 s=hs(n) print(s)",11,10,1,运行错误,A,"函数的返回值,赋值给变量s,输出11.","35,",4,0,0,函数的返回值,0,0
9981,0,1,"有如下Python程序,输出的结果是?( ) def whao(year = '2023'): print('你好' + year) whao()",你好,你好2023,你好year,没有输出,B,"调用函数whao,输出: 你好2023","35,",3,0,0,函数使用,0,0
9982,0,1,"编写计算正方体体积的匿名函数,下列哪一个语句是正确的?( )",rst = lambda a : a * 3,lambda a : a * 3,rst = lambda a : a ** 3,lambda a : a ** 3,C,"关键字lambda表示匿名函数,冒号之前表示的是这个函数的参数,冒号之后表示的是返回值,在定义匿名函数时,需要将它赋值给一个变量.","35,",4,0,0,匿名函数,0,0
9983,0,1,"执行如下Python程序,运行的结果是?( ) def zfzh(s): c = '' for ch in s: if ""9"">=ch>= ""0"": c+=str(int(ch)+1) elif ""z"">=ch>= ""a"": c+= chr(ord(ch)- ord(""a"")+ord(""A"")) return c s = 'hzag-21-8' print(zfzh(s))",HZAG329,923HZAG,GAZH329,923GAZH,A,"调用函数zfzh,注意字符串累加方式.","35,",5,0,0,函数使用,0,0
9984,0,1,"在Python中,以下哪个代码是安装numpy模块的方法?( )",pip install numpy,pip uninstall numpy,install numpy,setup numpy,A,可以安装numpy模块的命令:pip install numpy,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
9985,0,1,在Python中导入第三方库的主要关键字是?( ),from,import,pip,install,B,在Python中导入第三方库的关键字是import.,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
9986,0,1,"<阅微草堂笔记>里描述了槐树果实""响豆"",在夜里爆响,这种豆一棵树只有一粒,难以辨认出.所以古人就等槐树开花结果后,用许多布囊分别贮存豆荚,用来当枕头.夜里如果没有听到声音,便扔掉.如果有爆响声.然后把这一囊的豆荚又分成几个小囊装好,夜里再枕着听......如此这么分下去直到找到响豆.以上故事体现的算法是?( )",顺序查找,枚举算法,解析算法,分治算法,D,"分治算法的特征之一,就是将一个复杂的问题分成两个或更多的相同或相似的子问题,再把子问题分成更小的子问题.","35,",3,0,0,分治算法,0,0
9987,0,1,下列哪项不是分治算法所具有的特征?( ),求解问题的规模缩小到一定的程度就能够容易地解决,求解题可以分解为若干个规模较小的不同问题,利用求解问题分解出的子问题的解可以合并为该问题的解,求解问题所分解出的各个子问题是相互独立的,B,求解问题可以分解为若干个规模较小的相同问题.,"35,",3,0,0,分治算法,0,0
9988,0,1,"两位同学玩猜数字游戏,规则如下:一方在心里默想一个范围在1-100之间的数,如果另一方猜的数字比对方想的要大,就说大了;如果猜的数字比想的要小,就说小了,直到猜中数字.那么使用二分查找法最多需要猜测的次数是?( )",10,8,7,6,C,相当于用二分法在1-100之间查找某个数字.,"35,",5,0,0,分治算法,0,0
9989,0,1,"用递推算法求解n个自然数的乘积,请问代码中横线上需要填入的正确代码是?( ) def fact(n): s=1 for i in range(1,n+1): s=s*i return ________ a=fact(5) print(a)",s,i,fact(n-1),fact(n),A,"def fact(n): s=1 for i in range(1,n+1): s=s*i return s a=fact(5) print(a)","35,",4,0,0,递归与递推,0,0
9990,0,1,"一球从100米高度自由落下,每次落地后反跳回原高度的一半;再落下,求它在第10次落地时,共经过多少米?第10次反弹多高? 可以用下列代码解决这个问题,请问这段代码是基于( )算法编写的? high=100 s=0 sum=0 for i in range(10): s,high=high+high/2,high/2 sum=sum+s sum=sum-high print(sum) print(high)",递归,枚举,递推,二分,C,"递推按照一定的规律来计算序列中的第一项,而问题显然是一个等比数列,可以用递推来解决.代码中没有调用自身的情况,所以不是递归.","35,",4,0,0,递归与递推,0,0
9991,0,1,"用递归算法求1~n个连续自然数的乘积的代码如下,请选择合适的代码补全程序?( ) def Chengji(n): if n <=1: return 1 else: return _____?______ print(Chengji(3))",n*Chengji(n),n*Chengji(n-1),n*Chengji(n+1),n×Chengji(n-1),B,def Chengji(n): if n <=1: return 1 else: return n*Chengji(n-1) print(Chengji(3)),"35,",4,0,0,递归与递推,0,0
9992,0,1,"有一根绳子,第一次剪去一半多2米,第二次剪去剩下的一半多2米,第三次剪去剩下的一半多2米,第四次剪去剩下的一半多2米,第五次剪去剩下的一半多2米,此时绳子还剩2米.这根绳子长几米?想解决这个问题的话,可以采用以下哪种算法?( )",排序,递推,解析,枚举,B,"题目中的绳子长度是按相同的规律剪掉的,所以从后向前,可以按照这个规律来递推计算绳子的长度.","35,",4,0,0,递归与递推,0,0
9993,0,1,"小猴子第一天摘下若干桃子,当即吃掉一半,又多吃一个.第二天早上又将剩下的桃子吃一半,又多吃一个.以后每天早上吃前一天剩下的一半另加一个.到第5天早上猴子想再吃时,发现只剩下一个桃子了.问第一天猴子共摘多少个桃子? 这个问题可以用递归来解决,代码如下: def peach(day): if day==1: return 1 return (peach(day-1) + 1)*2 s=peach(5) print('一共有%d只桃子'%(s)) 请问第2行的""if day == 1""代码起到的作用是?( )",结束递归的边界条件,开始递归的边界条件,调用自身,递归过程中的变化,A,"递归算法有明确的结束递归的边界条件(又称终止条件)以及结束时的边界值,可以通过条件语句(if语句)实现.","35,",3,0,0,递归与递推,0,0
9994,0,1,"下列代码可以求两个数的最小公倍数.请认真阅读下列代码运用了什么算法?( ) def lcm(s,m,n): if s%n==0: return s else: return lcm(s+m,m,n) a=int(input('请输入第1个数:')) b=int(input('请输入第2个数:')) c=lcm(a,a,b) print('{}和{}的最小公倍数是{}'.format(a,b,c))",枚举,解析,递归,二分,C,"在定义一个函数或过程时,如果出现调用自身的成分,则称为递归.","35,",4,0,0,递归与递推,0,0
9995,0,1,"关于函数,正确的描述是?( )",规范的函数设计都应该带有返回值,"函数体中,只要遇到break关键字,函数就结束","函数体中,只要遇到return关键字,函数就结束","函数的返回值只能是整型,浮点型,布尔型和字符串",C,"Python函数中,一旦遇到return关键字,函数就结束运行.","35,",3,0,0,函数的相关概念,0,0
9996,0,1,"关于全局变量和局部变量,正确的描述是?( )","通俗来说,无缩进的变量都是全局变量","函数体中,只能使用局部变量","Python程序中,全局变量与局部变量不允许重名","函数体中,只能通过实参传递的方式实现对全局变量数值的使用",A,"无缩进的变量都在最上层,是全局变量.","35,",3,0,0,全局变量和局部变量,0,0
9997,0,1,"定义以下函数: def func(x,y,z=2): print(x+y+z) 分别以func(1,2,3)和func(1,2)语句调用该函数,运行后的结果分别是?( )",6;出错,5;出错,5;5,6;5,D,"Python中,形参设定了默认值后,在调用函数时还可以为该形参再传入新值.func(1,2,3)的值是6,func(1,2)的值是5.","35,",4,0,0,函数使用,0,0
9998,0,1,"在嵌套函数中,也就是一个函数里面还有一个函数,如果内部函数需要修改外部变量的值,处理的方法是?( )",只能通过不定长参数传递来实现,使用local关键字,使用nonlocal关键字,使用global关键字,D,"Python嵌套函数中,如果内部函数需要修改外部变量的值,要使用global关键字.","35,",4,0,0,全局变量和局部变量,0,0
9999,0,1,"在自定义函数中,如果发现局部变量与全局变量同名,则?( )","程序会出现语法错,不能运行","程序可以运行,局部变量与全局变量互不干扰","可能会出现局部变量修改全局变量的值的情况,需要检查程序设计是否合理","不允许出现这种情况,应该采用参数传递的方法去解决问题",B,"在Python函数中,如果局部变量与全局变量同名,则局部变量屏蔽全局变量.","35,",4,0,0,全局变量和局部变量,0,0
10169,4,3,"函数是将实现相同功能的代码封装在一起,实现代码复用.( )",,,,,1,"函数是将实现相同功能的代码封装在一起,实现代码复用.","35,",3,0,0,函数的相关概念,0,0
10170,4,3,"关键字实参通过""关键字=值""的方式传值,函数参数全部采用此方式传值时,不需要考虑函数调用过程中形参的顺序.( )",,,,,1,函数的概念.,"35,",3,0,0,函数的相关概念,0,0
10171,4,3,函数的定义代码不需要在主程序调用函数之前.( ),,,,,0,函数必须先定义才能调用.,"35,",3,0,0,自定义函数的创建与调用,0,0
10172,4,3,命令 pip download < 第三方库 > 表示下载并安装指定的第三方库.( ),,,,,0,该命令为下载但不安装.,"35,",4,0,0,"第三方库(模块)的获取,安装与调用",0,0
10173,4,3,"二分查找又称对折半查找,例如:在数列 34 , 17 , 25 , 9 , 10 , 3 中查找 3 ,适合采用二分查找法.( )",,,,,0,二分查找是一种应用于有序数列的高效查找算法.,"35,",4,0,0,分治算法,0,0
10174,4,3,"递归算法不涉及高深的数学知识,使得很多比较复杂的问题,也可以用简洁的代码解决,代码的执行效率比较高,所以即使有其他算法可行,也应该首选递归算法解决问题.( )","递归算法代码运行时会引起一系列函数调用,有不少重复计算,其执效率比较低.",,,,0,"递归算法代码运行时会引起一系列函数调用,有不少重复计算,其执效率比较低.","35,",3,0,0,递归与递推,0,0
10175,4,3,"递归算法中,必然存在函数体内调用自身的情况,可以在最后调用,也可以在中间调用.( )",,,,,1,"在定义一个函数或过程时,如果出现调用自身的成分,则称为递归.调用自身的位置根据具体情况而定,不强制要求在最后才能调用自身.","35,",4,0,0,递归与递推,0,0
10176,4,3,"Python 程序中,自定义函数可以放在整个程序的开头,也可以放在主程序之后,比较自由.( )",,,,,0,"Python程序中,自定义函数要放在主程序之前.","35,",4,0,0,自定义函数的创建与调用,0,0
10177,4,3,"通过把某些特定功能语句设计成自定义函数,可以简化主程序的编写.( )",,,,,1,"通过函数调用,可以简化主程序的编写.","35,",3,0,0,函数的相关概念,0,0
10178,4,3,"下面代码的时间复杂度为 O(n*n) .( ) arr = [ 2, 3, 4, 10, 40 ] n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1] : arr[j], arr[j+1] = arr[j+1], arr[j]",,,,,1,"双重循环,时间复杂度为 O(n*n) .","35,",5,0,0,时间复杂度与空间复杂度,0,0
10179,4,4,"从键盘上分别输入要查找和替换的字符串,对文本文件进行查找与替换,替换后保存到新的文本文件中. 思路:输入待查找字符串 s ,需查找子字符串 key 和替换字符串 new ,通过调用自定义函数 replace 实现替换.完善划线处代码. s = input("" 请输入待查找的字符串: "") key = input("" 请输入需查找的子字符串: "") new = input("" 请输入要替换的字符串: "") def findstr(key, s, begin): for i in range(begin,len(s) - len(key) + 1): if s[i: ① ]== key: return i return -1 def replace(key, new, s): begin = 0 while begin < ② : pos = findstr(key,s, begin) if pos ==-1: break else: s = s[0:pos]+ new + s[pos + len(key): ③ ] begin =  pos + len(key) return s rst = ④ # 调用函数替换字符 print(rst)",,,,,"<p class=""MsoNormal""><span><font face=""Calibri"">s = input(""</font><font face=""宋体"">请输入待查找的字符串:</font><font face=""Calibri"">"")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">key = input(""</font><font face=""宋体"">请输入需查找的子字符串:</font><font face=""Calibri"">"")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">new = input(""</font><font face=""宋体"">请输入要替换的字符串:</font><font face=""Calibri"">"")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">def findstr(key, s, begin):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">for i in range(begin,len(s) - len(key) + 1):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">if s[i:i+len(key)]== key:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return i &nbsp;</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return -1</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">def replace(key, new, s):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">begin = 0</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">while begin &lt; len(s)-len(key)+ 1:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">pos = findstr(key,s, begin)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">if pos ==-1:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">break</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">else:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">s = s[0:pos]+ new + s[pos + len(key):len(s)]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">begin = pos + len(key)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return s</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">rst = replace(key,new,s) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=""宋体"">调用函数替换字符</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">print(rst)</font></span><span><o:p></o:p></span></p>","评分标准: ( 1 ) i+len(key) 或等价答案;( 3 分 ) ( 2 ) len(s)-len(key)+ 1 或等价答案;( 3 分 ) ( 3 ) len(s) 或等价答案;( 3 分 ) ( 4 ) replace(key,new,s) 或等价答案.( 3 分 )","35,",,0,0,,0,0
10180,4,4,"一个列表中存在 n 个数据,可以用分治算法来找到其中的最小值.具体过程如下:如果列表元素的个数小于等于 2 的时候,经过一个判断就找到其中的最小值,所以可以先把数据从中间划分为左右两部分,然后通过递归把每一部分再划分为左右两部分,直到数据规模小于等于 2 的时候,返回结果,然后通过递归到最后为两个数据对比,我们就可以找到最小值. 请根据以上算法过程,补全代码. # 求列表中小于两个元素的最小值 def get_min(number): if len(number) == 1: return ① else: if number[1] > number[0]: return number[0] else: return number[1] def solve(number): n = len(number) if n <= 2: return get_min(number) else: # 将整个列表分为左右两部分 left_list, right_list = ② , number[n//2:] # 递归(树),分治 left_min, right_min = solve(left_list), ③ return get_min([left_min, right_min]) test_list = [5, 11, 3, 2, 7, 9] print(solve(test_list))",,,,,"<p class=""MsoNormal""><span>参考程序:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri""># </font><font face=""宋体"">求列表中小于两个元素的最小值</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">def get_min(number):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">if len(number) == 1:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return number[0]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">else:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">if number[1] &gt; number[0]:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return number[0]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">else:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return number[1]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">def solve(number):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">n = len(number)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">if n &lt;= 2:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return get_min(number)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">else:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri""># </font><font face=""宋体"">将整个列表分为左右两部分</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">left_list, right_list = number[:n//2], number[n//2:]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri""># </font><font face=""宋体"">递归(树),分治</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">left_min, right_min = solve(left_list), solve(right_list)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">return get_min([left_min, right_min])</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">test_list = [5, 11, 3, 2, 7, 9]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span><font face=""Calibri"">print(solve(test_list))</font></span><span><o:p></o:p></span></p>",评分标准: ( 1 ) number[0] ;( 2 分 ) ( 2 ) number[:n//2] ;( 3 分 ) ( 3 ) solve(right_list) .( 3 分 ),"35,",,0,0,,0,0
10181,4,4,"未来居民社区设计有一个机器人服务中心,假如某社区有若干栋住宅楼,每栋楼的位置可以由坐标 (x,y) 表示,其中 x 坐标表示居民楼的东西向位置, y 坐标表示居民楼的南北向位置.这里约定,社区中任意 2 点 (x1,y1) 和 (x2,y2) 的之间的距离使用数值 |x1-x2|+|y1-y2| 来度量.要求为社区选择建立机器人服务中心的最佳位置,使各个居民点到机器人服务中心的距离总和最小.以下是机器人服务中心的选址程序,采用取各坐标中位数的方法来确定中心位置,请补充完成该程序. 注:中位数的含义:一组按大小顺序排列起来的数据中处于中间位置的数.当有奇数个数据时 , 中位数就是中间那个数;当有偶数个数据时 , 中位数就是中间那两个数的平均数. n=int(input("" 请输入居民楼总数: "")) hx=[] hy=[] for i in range(n): x,y = map(int,input("" 请输入居民楼的 x 和 y 坐标: "").split("","")) hx. append(x) hy. append(y) hx = sorted( ① ) hy = sorted( ② ) if n%2 == 0:  # 偶数情况,求中位数 sn = int(n/2) x0 = int((hx[sn]+hx[sn-1])/2) y0 = int((hy[sn]+hy[sn-1])/2) else:         # 奇数情况,求中位数 sn = int((n-1)/2) x0 = ③ y0 = ④ sumx=0 sumy=0 for j in hx: dx =abs(x0-j) sumx += dx for k in hy: dy = abs(y0-k) sumy += dy print("" 选址点的坐标是: (%d,%d)""%(x0,y0)) print("" 选址到各楼的累计距离是: "",sumx+sumy)",,,,,"<p class=""MsoNormal""><span>参考程序:</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">n=int(input(""</font><font face=""宋体"">请输入居民楼总数:</font><font face=""Calibri"">""))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">hx=[]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">hy=[]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">#x,y = input(""</font><font face=""宋体"">请输入居民楼的</font><font face=""Calibri"">x</font><font face=""宋体"">和</font><font face=""Calibri"">y</font><font face=""宋体"">坐标:</font><font face=""Calibri"">"").split("","")</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">for i in range(n):</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">x,y = map(int,input(""</font><font face=""宋体"">请输入居民楼的</font><font face=""Calibri"">x</font><font face=""宋体"">和</font><font face=""Calibri"">y</font><font face=""宋体"">坐标:</font><font face=""Calibri"">"").split("",""))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">hx.append(x)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">hy.append(y)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">hx=sorted(hx) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=""宋体"">对输入坐标进行排序</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">hy=sorted(hy)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">if n%2 == 0: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=""宋体"">偶数情况,求中位数</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">sn = int(n/2)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">x0 = int((hx[sn]+hx[sn-1])/2)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">y0 = int((hy[sn]+hy[sn-1])/2)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">else: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#</font><font face=""宋体"">奇数情况,求中位数</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">sn = int((n-1)/2)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">x0 = hx[sn]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">y0 = hy[sn]</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">sumx=0</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">sumy=0</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">for j in hx:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">dx =abs(x0-j)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">sumx += dx</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">for k in hy:</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">dy = abs(y0-k)</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;&nbsp;<font face=""Calibri"">sumy += dy</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span>&nbsp;&nbsp;&nbsp;</span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">print(""</font><font face=""宋体"">选址点的坐标是:</font><font face=""Calibri"">(%d,%d)""%(x0,y0))</font></span><span><o:p></o:p></span></p><p class=""MsoNormal""><span>&nbsp;</span></p><p class=""MsoNormal""><span><font face=""Calibri"">print(""</font><font face=""宋体"">选址到各楼的累计距离是:</font><font face=""Calibri"">"",sumx+sumy)</font></span><span><o:p></o:p></span></p>",评分标准: ( 1 ) hx ;( 2 分 ) ( 2 ) hy ;( 2 分 ) ( 3 ) hx[sn] ;( 3 分 ) ( 4 ) hy[sn] .( 3 分 ),"35,",,0,0,,0,0
