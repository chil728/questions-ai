id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,examDots,difficultyLevel,weType,isMySubject,knowledgeNames,answerStatus,compileEnvironment
10307,4,1,下列有关分治算法思想的描述不正确的是?( ),将问题分解成的子问题具有相同的模式.,将问题分解出的各个子问题相互之间有公共子问题.,"当问题足够小时,可以直接求解.",可以将子问题的求解结果合并成原问题的解.,B,将问题分解出的各个子问题相互之间没有公共子问题.,"35,",4,0,0,分治算法,0,0
10308,4,1,"斐波那契数列前 n 项是 1,1,2,3,5,8,13...... 补全下面程序代码,求第 n 项斐波那契数列的值. def fib(n): if ______: return 1 else: return fib(n-1) + fib(n-2)",n == 2,n < 2,n == 3,n < 3,D,"用分治思想,递归求解.","35,",4,0,0,"递归与递推,分治算法",0,0
10309,4,1,"用分治法求两个数的最大公约数,代码和运行结果如下,请选择合适的代码完成程序?( ) def fun(m, n): if m % n == 0: return n else: return __________ print(fun(98, 56)) 程序运行结果如下: 14","fun(n, m-n)","fun(n, m%n)","fun(m, m-n)","fun(m, m%n)",B,"用分治算法,实现两个数的最大公约数求解.","35,",4,0,0,分治算法,0,0
10310,4,1,列出第三方库的详细信息的pip指令是?( ),pip install <第三方库名>,pip download<第三方库名>,pip show<第三方库名>,pip list<第三方库名>,C,pip命令,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
10311,4,1,"想要在 Python中导入math模块中的sqrt(x)函数,下列程序段错误的是?( )",import math math.sqrt(x),from math import sqrt as t t(x),from math import sqrt as t t(x),import mathsqrt(x),D,库使用,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
10312,4,1,"关于求解""找出所有满足各位数字之和等于8的三位数""时,在下列 数值范围内,算法执行效率最高的是?( )",0—999,0—1000,100—800,107—800,D,枚举的范围应尽可能小但又不遗漏 .,"35,",4,0,0,算法优化,0,0
10313,4,1,"已知,从1到n的连续自然数相乘的积叫做阶乘,用符号n!表示,比如3!=1×2×3,规定0!=1.那么用递归算法求n的阶乘,递归式正确的是?( )","f(0)=1,n=n*(n-1)","f(0)=1,f(n)=f(0)*f(n-1)","f(0)=1,f(n)=f(n)*f(n-1)","f(0)=1,f(n)=n*f(n-1)",D,"使用递归求解 n的阶乘 n! = 1 * 2* 3*...*n,这个式子写成递归式就是 n! = (n -1)! * n, 就把问题规模为n的问题转换为求解规模为n -1的问题.","35,",4,0,0,递归与递推,0,0
10314,4,1,"当 n为6时,运行下列Python程序后的结果是?( ) def f(n): if n<=2: return 1 else: return f(n-1)+f(n-2) n=int(input(""请输入一个正整数:"")) print(f(n))",5,8,11,13,B,"递归式看出每一项等于前两项之和,递推得出结果.","35,",4,0,0,递归与递推,0,0
10315,4,1,"下列程序中,当 n＝4时,返回结果为?( ) def x(n): if  n==1: return 1 else: return n+x(n-1)",12,11,10,9,C,"根据递归式,对 n求和.","35,",4,0,0,递归与递推,0,0
10316,4,1,"下列选项中,不属于递归特性的是?( )",递归函数一定包含条件控制语句,递归算法体现了大事化小的思想,"递归效率不高,递归层次过多会导致栈溢出","递归算法代码简洁,效率较高",D,"递归算法必须有结束递归的条件来终止递归,递归过程中进行递归调用的次数必须是有限的,算法效率不高.","35,",3,0,0,递归与递推,0,0
10317,4,1,"对于下列递归式子,当 n=4时,F的值是?( ) F(n)=F(n-1)*2 F(1)=2",2,8,16,32,C,"根据递归式,每一项等于前一项乘以 2.","35,",4,0,0,递归与递推,0,0
10318,4,1,"下面函数实现的功能是?( ) def   mi(x, n): if   n == 0: return  1 else: return  x*mi(x, n-1)",计算x的n次方,计算n的x次方,计算x!*n,计算x*n!,A,"根据递归式,求x的n次方.","35,",4,0,0,递归与递推,0,0
10319,4,1,"def afun(n): s=1 for i in range(1,n+1): s*=i return s 对以上代码解释错误的是?( )","程序正常运行时, afun(n)函数的作用是求n的阶乘","程序正常运行时, afun(n)函数的作用是求n+1的阶乘",s是局部变量,range()函数是Python内置函数,B,"在 range(a,b)函数中,范围包含a,不包含b.","35,",4,0,0,函数使用,0,0
10320,4,1,"关于下列代码解释错误的一项是?( ) def ZhongYao(a:str,b:int)->str: word=a*b print('重要的事情说{}遍:{}'.format(b,word)) return ZhongYao ZhongYao('学习','3')",参数 a的数据类型必须是字符串,参数 b的数据类型必须是整型,函数指定了返回值的数据类型是字符串,"程序正常运行,输出结果是: 重要的事情说 3遍:学习学习学习",D,"因为 a的值是'学习',b的值是'3',其数据类型均为字符串, 所以无法运行 word=a*b,故程序会报错.其余三项均正确.","35,",5,0,0,函数使用,0,0
10321,4,1,"下列代码的运行结果是?( ) def exchange(a,b): a,b=b,a print(a,b) a,b=3,5 exchange(a,b) print(a,b)",5 3 5 3,3 53 5,3 53 5,5 3 3 5,C,"函数体内的 a,b是局部变量,函数体外的a,b是全局变量.全 局变量的作用域是整个程序,局部变量的作用域是函数内部.","35,",4,0,0,全局变量和局部变量,0,0
10322,4,1,"下列代码的运行结果是?( ) def car_show(cars): for car in cars: print('good',car) car_show(['BYD','Haval','Wuling'])","good ['BYD','Haval','Wuling']","'good','BYD' 'good','Haval' 'good','Wuling'",good BYD Haval Wuling,good BYDgood Havalgood Wuling,D,"列表可以做为参数传递进函数体内,并且按列表的语法规则进行读取与修改.","35,",4,0,0,函数的相关概念,0,0
10323,4,1,"函数中定义了 4个参数,其中2个参数都指定了默认值,见下面代码,那么在调用函数时 参数个数最少是?( ) def SiBianXing(a,b,c=5,d=8): ZhouChang=a+b+c+d return ZhouChang SiBianXing( ? )",0,1,2,3,B,"设置了默认值的参数,在函数调用时可以不用传入值,此时采用默认值运行. 如果传入了新值,那么将使用新传入的值运行.","35,",4,0,0,函数使用,0,0
10325,4,1,"执行如下程序,以下选项中哪一项是错误的?( ) def f(a,b): c=a+b*2 b=a return c a=1 b=2 c=f(a,b)+b",该函数名称为 f,"执行该程序后,变量 a的值为1","执行该程序后,变量 b的值为2","执行该程序后,变量 c的值为6",D,"调用时函数返回值局部变量 a=1,b=1,c=5,调用结束后返回主程序, 全局变量 a=1,b=2,c=5+2=7.","35,",4,0,0,全局变量和局部变量,0,0
10327,4,1,以下哪种情况下的代码块适合设计成函数?( ),复杂的功能块,难以看懂的功能块,有性能要求的功能块,会多次用到的功能块,D,函数的根本目的是代码复用.,"35,",3,0,0,函数的相关概念,0,0
10330,4,1,"使用位置实参的方式调用函数时,下列哪种情况下程序一定会出错?( )",传入的实参个数比形参个数多,部分形参赋以默认值,"函数调用时,重新给赋予了默认值的形参传入新值",部分实参以关键字赋值的方式去调用函数,A,传入的实参个数要与函数定义时所提供的形参个数匹配.,"35,",4,0,0,函数的相关概念,0,0
10332,4,1,"下列函数定义中,正确的是?( )","def myfunc(a,b,c) print(myfunc(a,b))","def myfunc(a=1,b,c): print(myfunc(a,b,c))","def myfunc(a,b=1,c): print(myfunc(a,b,c))","def myfunc(a,b,c=1): print(myfunc(a,b,c))",D,"形参可以有默认值,但是有位置要求.","35,",4,0,0,自定义函数的创建与调用,0,0
10334,4,1,"调用函数的时候,所使用的参数是?( )",实参,位置参数,关键字参数,不定长参数,A,B-C均为形参,"35,",3,0,0,函数的相关概念,0,0
10336,4,1,"对于如下自定义的函数: def myfunc(a,b,c): return a+b+c 以下调用该函数的语句中,能正确执行的是?( )","myfunc(1,2)","myfunc(a=3,2,1)","myfunc(3,b=2,1)","myfunc(3,2,c=1)",D,"在形参列表中必须先列出没有默认值的形参,再列出有默认值的形参.","35,",4,0,0,自定义函数的创建与调用,0,0
10337,4,1,"使用 *args和**kwargs形参来定义函数时,正确的说法是?( )","使用 *args代表列表,使用**kwargs代表元组",可以在调用函数时传入多个实参,"使用 *args代表元组,使用**kwargs代表列表","使用 *args代表字典,使用**kwargs代表列表",B,"使用 *args和**kwargs形参来定义函数时,使用*args代表列表, 使用 **kwargs代表字典,这种形式可以在调用函数时传入多个实参.","35,",5,0,0,自定义函数的创建与调用,0,0
10338,4,1,"关于函数参数的默认值设置,描述不正确的是?( )","定义函数时,可以为某形参设定默认值","如果为某形参设定了默认值,则在调用函数时就不能再为该形参传入新值","如果为某形参设定了默认值,在调用函数时还可以为该形参再传入新值","如果为某形参设定了默认值,在调用函数时还可以为该形参再传入新值",B,"Python中,形参设定了默认值后,在调用函数时还可以为该形参再传入新值","35,",4,0,0,自定义函数的创建与调用,0,0
10339,4,3,"分治算法是把一个大问题分解为若干个规模较小,性质相同的子问题.最后子问题 可以简单地直接求解,将所有子问题的解合并起来就是原问题的解.( )",,,,,1,"分治算法的概念:分,治,合.","35,",3,0,0,分治算法,0,0
10340,4,3,"pip联网直接下载安装第三方库时,只能临时更换下载源,不能更改默认的下载源.( )",,,,,0,pip安装第三方库,"35,",3,0,0,"第三方库(模块)的获取,安装与调用",0,0
10446,4,3,运行以下代码的时间复杂度为O(n 2 ).( ) k=0 n=11 for i in range(n): k=k+1 for j in range(n):,,,,,0,"两个for语句不为嵌套,那么它们执行的时间复杂度只计算一个的就可以了,所以时间复杂度为O(n).","35,",5,0,0,时间复杂度与空间复杂度,0,0
10447,4,3,"对于递归而言,递推与回归,二者缺一不可.( )",,,,,1,递推关系是递归的重要组成.,"35,",3,0,0,递归与递推,0,0
10453,4,3,"递归算法必须确保,需要解决的问题可以转化为一个或多个子问题来求解,这些子问题的求解方法与原问题相同,只是在数量和规模上不同,而且每次递归调用时,问题规模都能够缩小.( )",,,,,1,"递归的核心思想就是自己调用自己,能够用递归解决问题的条件之一,是需要解决的问题可以转化为一个或多个子问题来求解,而这些子问题的求解方法与原问题相同,只是在数量和规模上不同.","35,",4,0,0,递归与递推,0,0
10455,4,3,"当函数运行结束后,局部变量的值依然存在,下次函数调用可以继续使用.( )",,,,,0,"局部变量的作用域是在函数体内,函数体内的代码运行完毕后,局部变量的值会在内存中被删除,下次函数调用时不能继续使用.","35,",4,0,0,全局变量和局部变量,0,0
10456,4,3,"内置函数不需要使用关键字import导入就可以使用,自定义函数可以先调用后定义.( )",,,,,0,"自定义函数必须要先定义,才能调用.","35,",3,0,0,自定义函数的创建与调用,0,0
10457,4,3,"编程时,需要把实现复杂功能的代码封装起来,设计成函数.( )",,,,,0,"程序设计中,可以把需要重复使用的代码封装起来,设计成函数.","35,",3,0,0,函数的相关概念,0,0
10458,4,3,"将实现特定功能的代码块设计成函数,有助于提高整个程序的运行速度.( )",,,,,0,"函数设计的主要目的是提高代码的复用率,并不提升程序的运行速度.","35,",3,0,0,函数的相关概念,0,0
10459,4,3,"如果允许形参设置默认值,则函数定义时要先列出没有默认值的形参,再列出有默认值的形参.( )",,,,,1,"Python函数,定义时要先列出没有默认值的形参,再列出有默认值的形参.","35,",4,0,0,形参和实参,0,0
10465,4,4,"统计高分问题 小张在学习对分查找后,想利用该思路来实践一下,加深对该算法的理解.于是他按老师的要求,统计期末考试成绩,总分比他高的同学有多少个? 他的思路是,首先将全区所有学生的成绩降序排序,然后利用对分查找思想解决.他编写的代码如下,请完善划线处的代码. cj =[654,643,621,612,609,606,...] #学生成绩存列表cj并已经降序排序 def dfsearch(key): i =0; j=len(cj)-1 while i<=j: m =(i+j)//2 if cj[m]>key: ① else: j-= 1 return ② key = int(input('输入待查找的成绩')) pos = ③ print('高于 ' ,key,'分的人数有',pos)",,,,,"<p><span>标准答案:</span></p><p><span><strong>参考程序:</strong></span></p><p>cj =[654,643,621,612,609,606,...]<span>#学生成绩存列表cj并已经降序排序</span></p><p>def&nbsp;dfsearch(key):<br>&nbsp; &nbsp; &nbsp; &nbsp;i =0; j=len(cj)-1<br>&nbsp; &nbsp; &nbsp;&nbsp;while&nbsp;i&lt;=j:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m =(i+j)//2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;cj[m]&gt;key:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span><strong>&nbsp;i +=1&nbsp; &nbsp;</strong></span>&nbsp;&nbsp; &nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-= 1<br>&nbsp; &nbsp; &nbsp; return&nbsp; &nbsp;<span><strong>&nbsp; &nbsp;i&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</strong></span><br>key =&nbsp;int(input('输入待查找的成绩'))<br>pos =&nbsp;<span><strong>&nbsp;dfsearch(key)</strong></span><br>print('高于<span>'</span>,key,'分的人数有',pos)&nbsp;</p>",评分标准: (1)i += 1或等价表达式;(2分) (2)i或等价表达式;(3分) (3)dfsearch(key)或等价表达式.(3分),"35,",,0,0,,0,0
10467,4,4,"比岁数问题 有5个人坐在一起,问第五个人多少岁?他说比第4个人大2岁.问第4个人岁数,他说比第3个人大2岁.问第三个人,又说比第2人大两岁.问第2个人,说比第一个人大两岁. 最后问第一个人,他说是10岁.请问第五个人多大? 请运用递归算法完成以下代码. def age(n): if         ①        : c = 10 else: c =        ② return c print(age(        ③        ))",,,,,<p>参考程序:</p><p><br></p><p>def age(n):</p><p>&nbsp; &nbsp; if n == 1:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; c = 10</p><p>&nbsp; &nbsp; else:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; c = age(n - 1) + 2</p><p>&nbsp; &nbsp; return c</p><p>print(age(5))</p>,试题解析: 评分标准: (1)n==1或等效答案;(3分) (2)age(n - 1) + 2或等效答案;(4分) (3)5或等效答案.(3分),"35,",,0,0,,0,0
10468,4,4,"数学证明问题 上世纪中期,校园里流行一种数学游戏,其规则十分简单:任意取一个自然数,若它是奇数,则把它乘以3加上1,若它是偶数,则除以2.按此规则进行下去,经过若干步的计算就能得到自然数1.这个数学现象至今都没有得到完全的证明,但是可以编程来验证它的正确性. 实现上述功能的部分程序代码如下,请补充完成空白处的内容. step = 1 midlist = [] def subwork(n): global step if n == 1: return step elif n % 2 == 0: n =         ① midlist. append(n) step +=  1 subwork(        ②        ) return step elif n % 2 != 0: n =         ③ midlist.        ④ step +=  1 subwork(        ⑤        ) return step cur_num = int(input(""请输入一个数字:"")) subwork(cur_num) print(midlist) print(step)",,,,,"<p>标准答案:</p><p><br></p><p>参考程序:</p><p><br></p><p>step = 1</p><p><br></p><p>midlist = []</p><p><br></p><p>&nbsp;</p><p><br></p><p>def subwork(n):</p><p><br></p><p>&nbsp; &nbsp; global step</p><p><br></p><p>&nbsp; &nbsp; if n == 1:</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp; &nbsp; elif n % 2 == 0:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; n = n / 2</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; midlist.append(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; step +=&nbsp; 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; subwork(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp; &nbsp; elif n % 2 != 0:</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; n = n * 3 + 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; midlist.append(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; step +=&nbsp; 1</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; subwork(n)</p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; return step</p><p><br></p><p>&nbsp;</p><p><br></p><p>cur_num = int(input(""请输入一个数字:""))</p><p><br></p><p>subwork(cur_num)</p><p><br></p><p>print(midlist)</p><p><br></p><p>print(step)</p>",评分标准: (1)n / 2或等效答案;(3分) (2)n或等效答案;(2分) (3)n * 3 + 1或等效答案;(3分) (4)append(n)或等效答案;(2分) (5)n 或等效答案.(2分),"35,",,0,0,,0,0
