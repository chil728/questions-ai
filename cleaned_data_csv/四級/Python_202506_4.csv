id,version,type,title,optionA,optionB,optionC,optionD,answer,analyzeContent,weType,isMySubject,answerStatus,compileEnvironment
1940294471715037186,0,1,"在Python中自定义函数f(x,y,z),参数x,y,z是整型变量,下列函数调用语句正确的是?( )",f,"f1,f2,f3","f(1,2,3)",f(123),C,"函数的调用方法是函数名称加实际参数,仿照f(x,y,z)的样子,将x,y,z依次替换为实际的数据.",0,0,0,0
1940294571945938946,0,1,"有如下Python程序段,执行该程序段后,输出的结果是?( ) def fun(x,y): if x >y: rst = 2 ** x else: rst = x ** 2 return rst x,y = 3,5 print(fun(x,y))",6,10,9,25,C,"调用函数后,因x>y条件不满足,故rst=x ** 2,即3**2,结果是9.",0,0,0,0
1940294652610793473,0,1,"有如下Python程序段,执行该程序段后,输出的结果是?( ) def js(x,y): rst = x * y - x // y return rst x,y = 3,5 print(js(x,y))",15,14.4,13.67,8,A,"函数将参数3和5分别传递给x和y,计算结果rst=3*5-3//5=15.",0,0,0,0
1940294737569173505,0,1,"有如下Python程序段,执行该程序段后,输出的结果是?( ) def zdz(a): m = 0 for i in range(1,len(a)): if a[i] > a[m]: m = i return m a = [1,5,6,5,4,3,9,0,8,9] print(zdz(a))",7,9,6,0,C,"函数zdz中计算数组a最大值的索引,故选C.",0,0,0,0
1940294883100762113,0,1,"有如下Python程序段,执行该程序段后输出的结果是?( ) def fac(n): s = 1 for i in range(1,n+1): s = s * i return s print(fac(5))",0,6,24,120,D,"函数fac(n)返回1*2*3*4*5的值,将n=5代入计算得到120.",0,0,0,0
1940294996820545538,0,1,"运行以下Python程序,表述中错误的选项是?( ) def de(a,b): c=a*2+b b=a return c a=10 b=20 c=de(a,b)+b",该函数名称为de,"执行该函数后,变量a的值为10","执行该函数后,变量b的值为20","执行该函数后,变量c的值为50",D,"调用后函数返回值局部变量c为40,调用结束时程序返回到调用出,全局变量c=40+20=60.故选D.",0,0,0,0
1940295140136099842,0,1,在Python中显示第三方库的详细信息的pip指令是?( ),pip install <第三方库名>,pip list <第三方库名>,pip show<第三方库名>,pip download <第三方库名>,C,pip命令,0,0,0,0
1940297600366202882,0,1,"生成1-10之间的随机整数,下列程序段不能实现该功能的是?( )","import random t = random.randint(1,10)","import random as ran t = ran.randint(1,10)","from random import randint t = randint(1,10)","import random t = randint(1,10)",D,库的调用,0,0,0,0
1940297728910479362,0,1,"小明想用lambda函数计算两个数的平方和,正确的写法是?( )","lambda a,b: a**2 + b**2","lambda a,b: return a**2 + b**2","lambda a,b -> a**2 + b**2","lambda (a,b): a**2 + b**2",A,"A:lambda a,b: a**2 + b**2 是正确写法,lambd函数隐式返回表达式结果,无需return. B:错误,lambda函数中不能显式使用return语句. C:错误,Python的lambda语法使用冒号(:)而非箭头(->). D:错误,Python 3中lambda的参数不能以元组形式声明(如(a,b)),应直接写成a,b.",0,0,0,0
1940297894795202562,0,1,"五一节庆到来,各大商场都推出折扣活动,小红打算写一个计算折扣的函数,但调用时报错,以下是小红编写的代码,错误的原因是?( ) def discount(price=100, rate): return price * rate print(discount(80))",默认参数 price 必须放在最后,rate 未指定默认值,"语法正确,无错误",缺少关键字参数,A,"默认参数必须位于参数列表末尾,此处rate未指定默认值且放在后面.",0,0,0,0
1940298011869368321,0,1,"小刚用lambda函数计算游戏技能冷却时间,以下代码的结果是?( ) cool_down = lambda t: t // 2 + 5 print(cool_down(10))",计算10秒的冷却时间为15秒,计算10秒的冷却时间为10//2+5=10秒,计算10秒的冷却时间为5秒,语法错误,B,"10//2=5,5+5=10,输出结果为10.",0,0,0,0
1940298267337859074,0,1,"老师想用 *args 统计学生成绩总和,以下正确的结果是?( ) def total_score(*scores): return sum(scores) print(total_score(80, 90, 70))",240,"(80, 90, 70)",报错,0,A,"*scores 将参数打包为元组,sum 计算总和为 80+90+70=240.",0,0,0,0
1940298425542811650,0,1,"以下lambda函数中,哪个会因变量未定义而报错?( )",lambda x: x + y,lambda x: x*2,"lambda x,y=5: x+y",lambda x: x**0.5,A,"A:lambda x: x + y,y未在lambda内部或外部定义,调用时会报NameError. B/C/D:均不依赖外部未定义变量,B和D仅操作参数,C使用默认值参数y=5,均合法.",0,0,0,0
1940298585559703554,0,1,下列关于函数的描述正确的是?( ),函数中必须return语句,"函数优点是模块化,但不能提高代码的利用 率","定义函数内容以冒号起始,可以不缩进","函数是可重复使用的,用来实现单一或相关联功能的代码段",D,"A错,函数中可以没有return语句.B错,函数可提高代码的复用率.C错,函数体必须缩进.故选D.",0,0,0,0
1940298660125659137,0,1,"社团活动中,小明分享一个编好的程序,小伙伴们试运行结果是?( ) def add(*arge): s=0 for i in args: s+=i return s s=add(2,3,4,5) print(s)",12,13,14,15,C,"编写的程序为s的依次累加,依次输入2,3,4,5,s=2+3+4+5=14.",0,0,0,0
1940298812257259522,0,1,"某物流公司需要每日处理数十万条配送路线数据,技术团队考虑使用分治算法或顺序查找算法进行路线规划,以优化货车路径并减少燃油消耗.已知城市大部分路线可分解为独立子问题.在以下哪种情况下,分治算法相比顺序查找更具优势?( )","当子问题之间存在大量重叠,需要重复计算时","当问题可以分解为相互独立的子问题,且合并结果简单时",当需要全局最优解且所有子问题必须精确计算时,"当问题规模较小,递归调用不会导致栈溢出时",B,"选项A:分治算法不解决此类问题. 选项B:分治算法的核心是分解-解决-合并,适用于子问题独立且合并成本低的场景(如归并排序,快速排序).例如,将城市划分为多个区域独立规划路径,最后合并结果. 选项C:分治算法可能因子问题独立性不一定是全局最优解. 选项D:问题规模小不是分治算法的核心优势,而是递归深度的技术限制.",0,0,0,0
1940298910739898369,0,1,"小明用""分治算法""编写了一个函数.他的任务是计算1+2+3+......+100的和. 请选择下列哪一项填入 ① 处,使程序运行成功?( ) def sum_range(start, end): if start == end: return start mid = (start + end) // 2 return sum_range(start, mid) + ① print(sum_range(1, 100))","sum_range(mid, end)","sum_range(mid+1, end)","sum_range(mid+1, end+1)","sum_range(mid, end-1)",B,"这里用""分治算法""把数的范围分成两个区域.前半部分是[start, mid], 后半部分是[mid+1, end] mid是中点.区域不断缩小,缩小到0返回数据本身.",0,0,0,0
1940302560631627777,0,1,"小明的班级有8个同学,每个人身上贴了一个不同的数字, 现在要举办一场""快速排序比赛"",规则如下: (1)设置两个变量i, j,排序开始时,i=0,j=N-1 . (2)以第一个元素作为关键数据,将其赋值给key, 即key = A[0] . (3)从j开始向前搜索,即由后向前搜索(j--), 找到第一个小于key的值A[j],将A[j]与A[i]交换. (4)从i开始向后搜索,即由前向后搜索(i++),找到第一个大于key的值A[i], 将A[i]与A[j]交换. (5)重复第(3),(4)步骤,直到i==j; (6)分成的前后两组数据,分别再按(1)~(5)递归排序,直到全部数据有序排列. 初始队伍顺序:[5, 3, 9, 1, 7, 2, 8, 6] 请问如果第一趟快速排序后,分组结果是什么?( )","前面[2, 3, 1], 后面[9, 7 , 8, 6]","前面[1, 2, 3], 后面[7, 9, 8, 6]","前面[2, 3, 1], 后面[7, 9, 8, 6]","前面[2, 1, 3], 后面[9, 7, 8, 6]",C,"开始 i=0,j=7, key=5 从后往前搜索 i=0,j=5, key=5 [2, 3, 9, 1, 7, 5, 8, 6] 从前往后搜索 i=2,j=5,key=5 [2, 3, 5, 1, 7, 9, 8, 6] 从后往前搜索 i=2,j=3,key=5 [2, 3, 1, 5, 7, 9, 8, 6] 第一趟排序结束.分成:前面[2, 3, 1]和后面[7, 9, 8, 6]",0,0,0,0
1940302629925724162,0,1,"光明小学有128位同学参加夏令营,老师为这些学生从1~128编上号码.现在老师随机抽取一个号码,让小明找到这位同学,小明想用二分查找的方法去查找,请问最差情况下需要查找几次才能找到这位同学?( )",5,6,7,8,C,128位同学可以这样分解:128->64->32->16->8->4->2->1 即最多查找7次,0,0,0,0
1940302720996265985,0,1,"在Python编程语言中,下面程序的输出结果是?( ) def f(a, b, c=0): return a + b + c print(f(3, 9))",12,3,9,报错,A,"函数返回值为a+b+c,和为12.",0,0,0,0
1940302855967526914,0,1,"一张彩纸厚度为0.2mm,求对折20次后的厚度,下面Python代码错误的地方是?( ) width= 0.2 for i in range(1,20): width = width *2","循环体错误,应该是width = width **2","循环次数错误,应该是range(20)","循环次数错误,应该是range(19)","循环体错误,应该是width +=width *2",B,"对折20次,循环体应该执行20次,每次厚度为上次的两倍,width=width*2",0,0,0,0
1940303030081474562,0,1,"小明每天做俯卧撑,第1天做10个,之后每天比前一天多2个.可以计算5天总训练量的Python递推程序是下列哪个选项?( )","total = 0 for day in range(1,6): total += 8 + 2*day",total = 10 for _ in range(4): total += total + 2,total = 10 current = 10 for _ in range(4): current += 2 total += current,def push_up(n): return 10*n + 2*(n-1),C,"初始10个,之后每天+2(第2天12,第3天14...总训练量=10+12+14+16+18).",0,0,0,0
1940303173233070082,0,1,"小陈每年存100元,年利率5%,要计算5年后总额(假设年利率没有变化),下面Python程序段采用的算法是哪种?( ) def total_money(n): money = 0 for i in range(n): money = (money + 100) * 1.05 return money",递归,二分法,递推,冒泡排序,C,"通过循环迭代计算每一期的金额,属于递推.",0,0,0,0
1940322473524252673,0,1,"小明每天跑步距离是前一天的两倍,下列哪个选项可表示第n天距离?( )",dis[n] = dis[n-1] * 2,dis[n] = dis[n-1] + 2,dis[n] = 2^n,dis[n] = n * 2,A,"每天距离是前一天的2倍,递推关系为乘法.",0,0,0,0
1940324540294537218,0,1,"某社团志愿者人数每天增长量为前一天的1.5倍,若第1天增长100人,用递归法计算第5天增长量,下面Python代码 ① 处应该填入哪个选项?( ) def growth(n): if n == 1: return 100 return ①",growth(n-1) + 100,1.5 ** (n-1) * 100,growth(n-1) * 1.5,growth(n-1) * n,C,"每天增长量是前一天的1.5倍,递归公式为 f(n) = 1.5 × f(n-1).",0,0,0,0
1940324592761085954,0,3,"有如下Python程序, def jf(a,b=0): return a+b 使用语句 jf(10) 调用函数,程序后输出10.( )",,,,,1,"关键字参数在函数调用时可以省略,jf函数调用时输出10.",0,0,0,0
1940324666719248386,0,3,"调用Python库时可以给其取一个别名,如执行语句import numpy as np后,在程序中可以用np代替numpy.( )",,,,,1,"调用库时为方便后续代码编写,可给其取一个别名,语句格式为import 库名称  as 别名.",0,0,0,0
1940324702008299521,0,3,"函数内修改全局变量时,必须使用global声明,否则会创建同名局部变量.( )",,,,,1,Python作用域规则要求显式声明全局变量才能修改.,0,0,0,0
1940324738055589889,0,3,"Python语言编程中,必须把每一个循环语句组封装起来,设计成函数.( )",,,,,0,"Python语言编程中,可以把需要重复使用的代码封装起来,设计成函数.",0,0,0,0
1940324786806366209,0,3,将代码封装成函数可以提高程序的执行速度.( ),,,,,0,"函数的主要作用是提高代码复用性和可读性,而非执行速度.频繁的函数调用可能因栈操作增加开销,但现代解释器优化后影响可忽略.",0,0,0,0
1940324825800810498,0,3,"下面的Python程序的时间复杂度是否为O(n 2 )?( ) n = 1000 total = 0 for i in range(n): for j in range(i, n): total += 1 print(total)",,,,,1,时间复杂度是O(n 2 ).,0,0,0,0
1940324868766879746,0,3,"在用""分治算法""计算8^4时,为了体现""分而治之""的算法思想,我们可以先把问题分解成8^2 * 8^2,而不是直接计算8*8*8*8.( ) (备注:8^4就是8的四次方)",,,,,1,"分治算法的设计思想是将一个难以直接解决的大问题,分割成一些规模较小的相同问题,以便各个击破,分而治之.",0,0,0,0
1940324911724941313,0,3,"在Python语言编程中,递归函数必须包含for循环.( )",,,,,0,递归通过函数自调用实现.,0,0,0,0
1940324948901810178,0,3,递推算法必须有明确的递推公式才能实现.( ),,,,,1,"每一个递推算法,都有一个递推公式,通过递推公式我们可以更加明确的了解递推算法.",0,0,0,0
1940324988980207618,0,3,"定义函数时含有位置参数和关键字参数时,关键字参数必须写在位置参数之后,否则会造成语法错误.( )",,,,,1,"当位置参数和关键字参数二者共存时,关键字参数必须写在位置参数之后,否则会造成语法错误.",0,0,0,0
1940325160785465346,0,4,"无人机社团 小明参加了一个无人机社团,现有n架无人机,编号为1, 2, 3, ..., n,依照规则出队执行任务.规则:从队列中按顺序出队第 k 架无人机,直到剩下最后一架无人机时,它将完成最终任务.现在需要计算第m架被出队的无人机的编号,请补充完成该程序. def solve(n, k, m): if ① :  #递归终止条件:当排除第1架时 return (n + k - 1) % ② #计算首轮被排除的位置 else: return (solve( ③ ) + k) % n n, k, m = map(int, input().split()) print( ④ )",,,,,,"标准答案: 参考程序: def solve(n, k, m): if m == 1:   # ① 递归终止条件:当排除第1架时 return (n + k - 1) % n   # ② 计算首轮被排除的位置 else: return (solve(n-1, k, m-1) + k) % n  # ③ 递归缩小问题规模 n, k, m = map(int, input().split()) print(solve(n, k, m) + 1)  # ④ 调整索引偏移(从1开始) 试题难度:较难 试题解析: 评分标准: (1)m == 1 (或等效答案);(2分) (2)n (或等效答案);(2分) (3)n-1, k, m-1(或等效答案);(2分) (4)solve(n, k, m) + 1(或等效答案).(2分)说明:solve(n, k, m)给1分",0,0,0,0
1940325232543440897,0,4,"岩浆活动 2024年,我国科学家通过对嫦娥六号月壤样品的分析研究,发现月球背面某区域的岩浆活动层数呈现递减规律: 最上层有n层岩浆活动,下一层岩浆活动层数是上一层的三分之一(向下取整),直到层数小于等于1时停止. 此外,每层岩浆活动有一个厚度值,最上层厚度为t,下一层厚度为上一层的0.5倍. 请完善以下程序,计算该区域的总岩浆活动层数和总厚度. def moon(n, t): """""" 计算月球某区域的总岩浆活动层数和总厚度 n: 最上层的岩浆活动层数 t: 最上层的岩浆活动厚度 return: (总层数, 总厚度) """""" if ① : return 1, t else: sub_layers, sub_thickness = moon(n // 3, ② ) return ③ , t + sub_thickness # 测试代码 n = int(input(""请输入最上层的岩浆活动层数:"")) t = float(input(""请输入最上层的岩浆活动厚度:"")) total_layers, total_thickness = ④ print(f""该区域的总岩浆活动层数为:{total_layers}"") print(f""该区域的总岩浆活动厚度为:{total_thickness}"")",,,,,,"参考程序 def moon(n, t): """""" 计算月球某区域的总岩浆活动层数和总厚度 n: 最上层的岩浆活动层数 t: 最上层的岩浆活动厚度 return: (总层数, 总厚度) """""" if n <= 1: return 1, t else: sub_layers, sub_thickness = moon(n // 3, t * 0.5) return n + sub_layers, t + sub_thickness # 测试代码 n = int(input(""请输入最上层的岩浆活动层数:"")) t = float(input(""请输入最上层的岩浆活动厚度:"")) total_layers, total_thickness = moon(n, t) print(f""该区域的总岩浆活动层数为:{total_layers}"") print(f""该区域的总岩浆活动厚度为:{total_thickness}"") 试题难度:一般 试题解析: 评分标准: (1)n <= 1(或等效答案);(2分) (2)t * 0.5 (或等效答案);(3分) (3)n + sub_layers (或等效答案);(3分) (4)moon(n, t)(或等效答案).(2分)",0,0,0,0
1940325405057536001,0,4,"收费标准 某快递公司对于不同重量的包裹和不同的寄送距离有不同的收费标准.该公司将寄送距离分为两个区间: 在距离 distance 小于或等于 1000 公里时,如果包裹重量weight小于等于 2 千克,收费 base_near 元;如果重量大于 2 千克,超出 2 千克的部分每千克收费 extra_near 元. 在距离大于 1000 公里时,如果包裹重量小于等于 2 千克,收费 base_far 元;如果重量大于 2 千克,超出 2 千克的部分每千克收费 extra_far 元.编写一个函数来计算包裹的快递费用,完善空白处代码. def courier_fee(weight, distance, base_near, extra__near, base_far, extra_far): if distance <= 1000: if         ①        : fee = base_near else: ② fee = base_near + extra_charge else: if weight <= 2: fee =         ③ else: ④ fee = base_far + extra_charge return fee # 调用函数计算快递费用 result = courier_fee(5, 1500, 10, 3, 15, 5) print(result)",,,,,,"标准答案: 参考程序: def courier_fee(weight, distance, base_near, extra_near, base_far, extra_far): if distance <= 1000: if weight <= 2 : fee = base_near else: extra_charge = (weight-2) * extra_near fee = base_near + extra_charge else: if weight <= 2: f ee = base_far else: extra_charge = (weight - 2) * extra_far fee = base_far + extra_charge return fee # 调用函数计算快递费用 result = courier_fee(5, 1500, 10, 3, 15, 5) print(result) 评分标准: (1)weight <= 2(或等效答案);  (2分) (2)extra_charge = (weight-2) * extra_near(或等效答案); (4分) (3)base_far(或等效答案);   (2分) (4)extra_charge = (weight - 2) * extra_far (或等效答案).(4分)",0,0,0,0
